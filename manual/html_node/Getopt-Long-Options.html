<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Getopt%20Long%20Options">Getopt Long Options</a>,
Next:<a rel=next accesskey=n href="Getopt-Long-Option-Example.html#Getopt%20Long%20Option%20Example">Getopt Long Option Example</a>,
Previous:<a rel=previous accesskey=p href="Example-of-Getopt.html#Example%20of%20Getopt">Example of Getopt</a>,
Up:<a rel=up accesskey=u href="Getopt.html#Getopt">Getopt</a>
<hr><br>

<h4>Parsing Long Options with <code>getopt_long</code></h4>

<p>To accept GNU-style long options as well as single-character options,
use <code>getopt_long</code> instead of <code>getopt</code>.  This function is
declared in <code>getopt.h</code>, not <code>unistd.h</code>.  You should make every
program accept long options if it uses any options, for this takes
little extra work and helps beginners remember how to use the program.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct option</b><i>
</i></td>
<td align="right">Data Type</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This structure describes a single long option name for the sake of
<code>getopt_long</code>.  The argument <var>longopts</var> must be an array of
these structures, one for each long option.  Terminate the array with an
element containing all zeros.

<p>The <code>struct option</code> structure has these fields:

<dl>
<dt><code>const char *name</code>
<dd>This field is the name of the option.  It is a string.

<br><dt><code>int has_arg</code>
<dd>This field says whether the option takes an argument.  It is an integer,
and there are three legitimate values: <code>no_argument</code>,
<code>required_argument</code> and <code>optional_argument</code>.

<br><dt><code>int *flag</code>
<dt><code>int val</code>
<dd>These fields control how to report or act on the option when it occurs.

<p>If <code>flag</code> is a null pointer, then the <code>val</code> is a value which
identifies this option.  Often these values are chosen to uniquely
identify particular long options.

<p>If <code>flag</code> is not a null pointer, it should be the address of an
<code>int</code> variable which is the flag for this option.  The value in
<code>val</code> is the value to store in the flag to indicate that the option
was seen. 
</dl>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>getopt_long</b><i> (int <var>argc</var>, char *const *<var>argv</var>, const char *<var>shortopts</var>, const struct option *<var>longopts</var>, int *<var>indexptr</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Decode options from the vector <var>argv</var> (whose length is <var>argc</var>). 
The argument <var>shortopts</var> describes the short options to accept, just as
it does in <code>getopt</code>.  The argument <var>longopts</var> describes the long
options to accept (see above).

<p>When <code>getopt_long</code> encounters a short option, it does the same
thing that <code>getopt</code> would do: it returns the character code for the
option, and stores the options argument (if it has one) in <code>optarg</code>.

<p>When <code>getopt_long</code> encounters a long option, it takes actions based
on the <code>flag</code> and <code>val</code> fields of the definition of that
option.

<p>If <code>flag</code> is a null pointer, then <code>getopt_long</code> returns the
contents of <code>val</code> to indicate which option it found.  You should
arrange distinct values in the <code>val</code> field for options with
different meanings, so you can decode these values after
<code>getopt_long</code> returns.  If the long option is equivalent to a short
option, you can use the short option's character code in <code>val</code>.

<p>If <code>flag</code> is not a null pointer, that means this option should just
set a flag in the program.  The flag is a variable of type <code>int</code>
that you define.  Put the address of the flag in the <code>flag</code> field. 
Put in the <code>val</code> field the value you would like this option to
store in the flag.  In this case, <code>getopt_long</code> returns <code>0</code>.

<p>For any long option, <code>getopt_long</code> tells you the index in the array
<var>longopts</var> of the options definition, by storing it into
<code>*<var>indexptr</var></code>.  You can get the name of the option with
<code><var>longopts</var>[*<var>indexptr</var>].name</code>.  So you can distinguish among
long options either by the values in their <code>val</code> fields or by their
indices.  You can also distinguish in this way among long options that
set flags.

<p>When a long option has an argument, <code>getopt_long</code> puts the argument
value in the variable <code>optarg</code> before returning.  When the option
has no argument, the value in <code>optarg</code> is a null pointer.  This is
how you can tell whether an optional argument was supplied.

<p>When <code>getopt_long</code> has no more options to handle, it returns
<code>-1</code>, and leaves in the variable <code>optind</code> the index in
<var>argv</var> of the next remaining argument. 
</td></tr>
</table>

<p>Since long option names were used before before the <code>getopt_long</code>
options was invented there are program interfaces which require programs
to recognize options like <code>-option&nbsp;value</code> instead of
<code>--option&nbsp;value</code>.  To enable these programs to use the GNU
getopt functionality there is one more function available.

<p>
<table width="100%">
<tr>
<td align="left">int <b>getopt_long_only</b><i> (int <var>argc</var>, char *const *<var>argv</var>, const char *<var>shortopts</var>, const struct option *<var>longopts</var>, int *<var>indexptr</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<p>The <code>getopt_long_only</code> function is equivalent to the
<code>getopt_long</code> function but it allows to specify the user of the
application to pass long options with only <code>-</code> instead of
<code>--</code>.  The <code>--</code> prefix is still recognized but instead of
looking through the short options if a <code>-</code> is seen it is first
tried whether this parameter names a long option.  If not, it is parsed
as a short option.

<p>Assuming <code>getopt_long_only</code> is used starting an application with

<br><pre>  app -foo
</pre>

<p>the <code>getopt_long_only</code> will first look for a long option named
<code>foo</code>.  If this is not found, the short options <code>f</code>, <code>o</code>,
and again <code>o</code> are recognized. 
</td></tr>
</table>

</body></html>

