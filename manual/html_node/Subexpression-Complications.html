<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Subexpression%20Complications">Subexpression Complications</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Regexp-Cleanup.html#Regexp%20Cleanup">Regexp Cleanup</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Regexp-Subexpressions.html#Regexp%20Subexpressions">Regexp Subexpressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Regular-Expressions.html#Regular%20Expressions">Regular Expressions</a>
<hr><br>
</div>

<h3 class="subsection">Complications in Subexpression Matching</h4>

<p>Sometimes a subexpression matches a substring of no characters.  This
happens when <code>f\(o*\)</code> matches the string <code>fum</code>.  (It really
matches just the <code>f</code>.)  In this case, both of the offsets identify
the point in the string where the null substring was found.  In this
example, the offsets are both <code>1</code>.

   <p>Sometimes the entire regular expression can match without using some of
its subexpressions at all--for example, when <code>ba\(na\)*</code> matches the
string <code>ba</code>, the parenthetical subexpression is not used.  When
this happens, <code>regexec</code> stores <code>-1</code> in both fields of the
element for that subexpression.

   <p>Sometimes matching the entire regular expression can match a particular
subexpression more than once--for example, when <code>ba\(na\)*</code>
matches the string <code>bananana</code>, the parenthetical subexpression
matches three times.  When this happens, <code>regexec</code> usually stores
the offsets of the last part of the string that matched the
subexpression.  In the case of <code>bananana</code>, these offsets are
<code>6</code> and <code>8</code>.

   <p>But the last match is not always the one that is chosen.  It's more
accurate to say that the last <em>opportunity</em> to match is the one
that takes precedence.  What this means is that when one subexpression
appears within another, then the results reported for the inner
subexpression reflect whatever happened on the last match of the outer
subexpression.  For an example, consider <code>\(ba\(na\)*s \)*</code> matching
the string <code>bananas bas </code>.  The last time the inner expression
actually matches is near the end of the first word.  But it is
<em>considered</em> again in the second word, and fails to match there. 
<code>regexec</code> reports nonuse of the "na" subexpression.

   <p>Another place where this rule applies is when the regular expression
<pre class="smallexample">     \(ba\(na\)*s \|nefer\(ti\)* \)*
     </pre>

<p>matches <code>bananas nefertiti</code>.  The "na" subexpression does match
in the first word, but it doesn't match in the second word because the
other alternative is used there.  Once again, the second repetition of
the outer subexpression overrides the first, and within that second
repetition, the "na" subexpression is not used.  So <code>regexec</code>
reports nonuse of the "na" subexpression.

   </body></html>

