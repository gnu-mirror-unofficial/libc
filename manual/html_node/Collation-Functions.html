<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Collation%20Functions">Collation Functions</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Search-Functions.html#Search%20Functions">Search Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="String-Array-Comparison.html#String%2fArray%20Comparison">String/Array Comparison</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="String-and-Array-Utilities.html#String%20and%20Array%20Utilities">String and Array Utilities</a>
<hr><br>
</div>

<h3 class="section">Collation Functions</h3>

<p>In some locales, the conventions for lexicographic ordering differ from
the strict numeric ordering of character codes.  For example, in Spanish
most glyphs with diacritical marks such as accents are not considered
distinct letters for the purposes of collation.  On the other hand, the
two-character sequence <code>ll</code> is treated as a single letter that is
collated immediately after <code>l</code>.

   <p>You can use the functions <code>strcoll</code> and <code>strxfrm</code> (declared in
the headers file <code>string.h</code>) and <code>wcscoll</code> and <code>wcsxfrm</code>
(declared in the headers file <code>wchar</code>) to compare strings using a
collation ordering appropriate for the current locale.  The locale used
by these functions in particular can be specified by setting the locale
for the <code>LC_COLLATE</code> category; see <a href="Locales.html#Locales">Locales</a>.

   <p>In the standard C locale, the collation sequence for <code>strcoll</code> is
the same as that for <code>strcmp</code>.  Similarly, <code>wcscoll</code> and
<code>wcscmp</code> are the same in this situation.

   <p>Effectively, the way these functions work is by applying a mapping to
transform the characters in a string to a byte sequence that represents
the string's position in the collating sequence of the current locale. 
Comparing two such byte sequences in a simple fashion is equivalent to
comparing the strings with the locale's collating sequence.

   <p>The functions <code>strcoll</code> and <code>wcscoll</code> perform this translation
implicitly, in order to do one comparison.  By contrast, <code>strxfrm</code>
and <code>wcsxfrm</code> perform the mapping explicitly.  If you are making
multiple comparisons using the same string or set of strings, it is
likely to be more efficient to use <code>strxfrm</code> or <code>wcsxfrm</code> to
transform all the strings just once, and subsequently compare the
transformed strings with <code>strcmp</code> or <code>wcscmp</code>.

<p>
<table width="100%">
<tr>
<td align="left">int <b>strcoll</b><i> </i>(<i>const char *</i><var>s1</var><i>, const char *</i><var>s2</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strcoll</code> function is similar to <code>strcmp</code> but uses the
collating sequence of the current locale for collation (the
<code>LC_COLLATE</code> locale). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>wcscoll</b><i> </i>(<i>const wchar_t *</i><var>ws1</var><i>, const wchar_t *</i><var>ws2</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcscoll</code> function is similar to <code>wcscmp</code> but uses the
collating sequence of the current locale for collation (the
<code>LC_COLLATE</code> locale). 
</td></tr>
</table>

   <p>Here is an example of sorting an array of strings, using <code>strcoll</code>
to compare them.  The actual sort algorithm is not written here; it
comes from <code>qsort</code> (see <a href="Array-Sort-Function.html#Array%20Sort%20Function">Array Sort Function</a>).  The job of the
code shown here is to say how to compare the strings while sorting them. 
(Later on in this section, we will show a way to do this more
efficiently using <code>strxfrm</code>.)

<pre class="smallexample">     /* This is the comparison function used with <code>qsort</code>. */
     
     int
     compare_elements (char **p1, char **p2)
     {
       return strcoll (*p1, *p2);
     }
     
     /* This is the entry point--the function to sort
        strings using the locale's collating sequence. */
     
     void
     sort_strings (char **array, int nstrings)
     {
       /* Sort <code>temp_array</code> by comparing the strings. */
       qsort (array, nstrings,
              sizeof (char *), compare_elements);
     }
     </pre>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>strxfrm</b><i> </i>(<i>char *restrict </i><var>to</var><i>, const char *restrict </i><var>from</var><i>, size_t </i><var>size</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The function <code>strxfrm</code> transforms the string <var>from</var> using the
collation transformation determined by the locale currently selected for
collation, and stores the transformed string in the array <var>to</var>.  Up
to <var>size</var> characters (including a terminating null character) are
stored.

     <p>The behavior is undefined if the strings <var>to</var> and <var>from</var>
overlap; see <a href="Copying-and-Concatenation.html#Copying%20and%20Concatenation">Copying and Concatenation</a>.

     <p>The return value is the length of the entire transformed string.  This
value is not affected by the value of <var>size</var>, but if it is greater
or equal than <var>size</var>, it means that the transformed string did not
entirely fit in the array <var>to</var>.  In this case, only as much of the
string as actually fits was stored.  To get the whole transformed
string, call <code>strxfrm</code> again with a bigger output array.

     <p>The transformed string may be longer than the original string, and it
may also be shorter.

     <p>If <var>size</var> is zero, no characters are stored in <var>to</var>.  In this
case, <code>strxfrm</code> simply returns the number of characters that would
be the length of the transformed string.  This is useful for determining
what size the allocated array should be.  It does not matter what
<var>to</var> is if <var>size</var> is zero; <var>to</var> may even be a null pointer. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>wcsxfrm</b><i> </i>(<i>wchar_t *restrict </i><var>wto</var><i>, const wchar_t *</i><var>wfrom</var><i>, size_t </i><var>size</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The function <code>wcsxfrm</code> transforms wide character string <var>wfrom</var>
using the collation transformation determined by the locale currently
selected for collation, and stores the transformed string in the array
<var>wto</var>.  Up to <var>size</var> wide characters (including a terminating null
character) are stored.

     <p>The behavior is undefined if the strings <var>wto</var> and <var>wfrom</var>
overlap; see <a href="Copying-and-Concatenation.html#Copying%20and%20Concatenation">Copying and Concatenation</a>.

     <p>The return value is the length of the entire transformed wide character
string.  This value is not affected by the value of <var>size</var>, but if
it is greater or equal than <var>size</var>, it means that the transformed
wide character string did not entirely fit in the array <var>wto</var>.  In
this case, only as much of the wide character string as actually fits
was stored.  To get the whole transformed wide character string, call
<code>wcsxfrm</code> again with a bigger output array.

     <p>The transformed wide character string may be longer than the original
wide character string, and it may also be shorter.

     <p>If <var>size</var> is zero, no characters are stored in <var>to</var>.  In this
case, <code>wcsxfrm</code> simply returns the number of wide characters that
would be the length of the transformed wide character string.  This is
useful for determining what size the allocated array should be (remember
to multiply with <code>sizeof (wchar_t)</code>).  It does not matter what
<var>wto</var> is if <var>size</var> is zero; <var>wto</var> may even be a null pointer. 
</td></tr>
</table>

   <p>Here is an example of how you can use <code>strxfrm</code> when
you plan to do many comparisons.  It does the same thing as the previous
example, but much faster, because it has to transform each string only
once, no matter how many times it is compared with other strings.  Even
the time needed to allocate and free storage is much less than the time
we save, when there are many strings.

<pre class="smallexample">     struct sorter { char *input; char *transformed; };
     
     /* This is the comparison function used with <code>qsort</code>
        to sort an array of <code>struct sorter</code>. */
     
     int
     compare_elements (struct sorter *p1, struct sorter *p2)
     {
       return strcmp (p1-&gt;transformed, p2-&gt;transformed);
     }
     
     /* This is the entry point--the function to sort
        strings using the locale's collating sequence. */
     
     void
     sort_strings_fast (char **array, int nstrings)
     {
       struct sorter temp_array[nstrings];
       int i;
     
       /* Set up <code>temp_array</code>.  Each element contains
          one input string and its transformed string. */
       for (i = 0; i &lt; nstrings; i++)
         {
           size_t length = strlen (array[i]) * 2;
           char *transformed;
           size_t transformed_length;
     
           temp_array[i].input = array[i];
     
           /* First try a buffer perhaps big enough.  */
           transformed = (char *) xmalloc (length);
     
           /* Transform <code>array[i]</code>.  */
           transformed_length = strxfrm (transformed, array[i], length);
     
           /* If the buffer was not large enough, resize it
              and try again.  */
           if (transformed_length &gt;= length)
             {
               /* Allocate the needed space. +1 for terminating
                  <code>NUL</code> character.  */
               transformed = (char *) xrealloc (transformed,
                                                transformed_length + 1);
     
               /* The return value is not interesting because we know
                  how long the transformed string is.  */
               (void) strxfrm (transformed, array[i],
                               transformed_length + 1);
             }
     
           temp_array[i].transformed = transformed;
         }
     
       /* Sort <code>temp_array</code> by comparing transformed strings. */
       qsort (temp_array, sizeof (struct sorter),
              nstrings, compare_elements);
     
       /* Put the elements back in the permanent array
          in their sorted order. */
       for (i = 0; i &lt; nstrings; i++)
         array[i] = temp_array[i].input;
     
       /* Free the strings we allocated. */
       for (i = 0; i &lt; nstrings; i++)
         free (temp_array[i].transformed);
     }
     </pre>

   <p>The interesting part of this code for the wide character version would
look like this:

<pre class="smallexample">     void
     sort_strings_fast (wchar_t **array, int nstrings)
     {
       ...
           /* Transform <code>array[i]</code>.  */
           transformed_length = wcsxfrm (transformed, array[i], length);
     
           /* If the buffer was not large enough, resize it
              and try again.  */
           if (transformed_length &gt;= length)
             {
               /* Allocate the needed space. +1 for terminating
                  <code>NUL</code> character.  */
               transformed = (wchar_t *) xrealloc (transformed,
                                                   (transformed_length + 1)
                                                   * sizeof (wchar_t));
     
               /* The return value is not interesting because we know
                  how long the transformed string is.  */
               (void) wcsxfrm (transformed, array[i],
                               transformed_length + 1);
             }
       ...
     </pre>

<p>Note the additional multiplication with <code>sizeof (wchar_t)</code> in the
<code>realloc</code> call.

   <p><strong>Compatibility Note:</strong> The string collation functions are a new
feature of ISO&nbsp;C90.  Older C dialects have no equivalent feature. 
The wide character versions were introduced in Amendment&nbsp;1 to ISO&nbsp;C90.

   </body></html>

