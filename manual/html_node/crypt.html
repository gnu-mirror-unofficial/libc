<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="crypt">crypt</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="DES-Encryption.html#DES%20Encryption">DES Encryption</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="getpass.html#getpass">getpass</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Cryptographic-Functions.html#Cryptographic%20Functions">Cryptographic Functions</a>
<hr><br>
</div>

<h3 class="section">Encrypting Passwords</h3>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>crypt</b><i> </i>(<i>const char *</i><var>key</var><i>, const char *</i><var>salt</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>The <code>crypt</code> function takes a password, <var>key</var>, as a string, and
a <var>salt</var> character array which is described below, and returns a
printable ASCII string which starts with another salt.  It is believed
that, given the output of the function, the best way to find a <var>key</var>
that will produce that output is to guess values of <var>key</var> until the
original value of <var>key</var> is found.

     <p>The <var>salt</var> parameter does two things.  Firstly, it selects which
algorithm is used, the MD5-based one or the DES-based one.  Secondly, it
makes life harder for someone trying to guess passwords against a file
containing many passwords; without a <var>salt</var>, an intruder can make a
guess, run <code>crypt</code> on it once, and compare the result with all the
passwords.  With a <var>salt</var>, the intruder must run <code>crypt</code> once
for each different salt.

     <p>For the MD5-based algorithm, the <var>salt</var> should consist of the string
<code>$1$</code>, followed by up to 8 characters, terminated by either
another <code>$</code> or the end of the string.  The result of <code>crypt</code>
will be the <var>salt</var>, followed by a <code>$</code> if the salt didn't end
with one, followed by 22 characters from the alphabet
<code>./0-9A-Za-z</code>, up to 34 characters total.  Every character in the
<var>key</var> is significant.

     <p>For the DES-based algorithm, the <var>salt</var> should consist of two
characters from the alphabet <code>./0-9A-Za-z</code>, and the result of
<code>crypt</code> will be those two characters followed by 11 more from the
same alphabet, 13 in total.  Only the first 8 characters in the
<var>key</var> are significant.

     <p>The MD5-based algorithm has no limit on the useful length of the
password used, and is slightly more secure.  It is therefore preferred
over the DES-based algorithm.

     <p>When the user enters their password for the first time, the <var>salt</var>
should be set to a new string which is reasonably random.  To verify a
password against the result of a previous call to <code>crypt</code>, pass
the result of the previous call as the <var>salt</var>. 
</td></tr>
</table>

   <p>The following short program is an example of how to use <code>crypt</code> the
first time a password is entered.  Note that the <var>salt</var> generation
is just barely acceptable; in particular, it is not unique between
machines, and in many applications it would not be acceptable to let an
attacker know what time the user's password was last set.

<pre class="smallexample">

     #include &lt;stdio.h&gt;
     #include &lt;time.h&gt;
     #include &lt;unistd.h&gt;
     #include &lt;crypt.h&gt;
     
     int
     main(void)
     {
       unsigned long seed[2];
       char salt[] = "$1$........";
       const char *const seedchars =
         "./0123456789ABCDEFGHIJKLMNOPQRST"
         "UVWXYZabcdefghijklmnopqrstuvwxyz";
       char *password;
       int i;
     
       /* Generate a (not very) random seed.
          You should do it better than this... */
       seed[0] = time(NULL);
       seed[1] = getpid() ^ (seed[0] &gt;&gt; 14 &amp; 0x30000);
     
       /* Turn it into printable characters from `seedchars'. */
       for (i = 0; i &lt; 8; i++)
         salt[3+i] = seedchars[(seed[i/5] &gt;&gt; (i%5)*6) &amp; 0x3f];
     
       /* Read in the user's password and encrypt it. */
       password = crypt(getpass("Password:"), salt);
     
       /* Print the results. */
       puts(password);
       return 0;
     }
     </pre>

   <p>The next program shows how to verify a password.  It prompts the user
for a password and prints "Access granted." if the user types
<code>GNU libc manual</code>.

<pre class="smallexample">

     #include &lt;stdio.h&gt;
     #include &lt;string.h&gt;
     #include &lt;unistd.h&gt;
     #include &lt;crypt.h&gt;
     
     int
     main(void)
     {
       /* Hashed form of "GNU libc manual". */
       const char *const pass = "$1$/iSaq7rB$EoUw5jJPPvAPECNaaWzMK/";
     
       char *result;
       int ok;
     
       /* Read in the user's password and encrypt it,
          passing the expected password in as the salt. */
       result = crypt(getpass("Password:"), pass);
     
       /* Test the result. */
       ok = strcmp (result, pass) == 0;
     
       puts(ok ? "Access granted." : "Access denied.");
       return ok ? 0 : 1;
     }
     </pre>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>crypt_r</b><i> </i>(<i>const char *</i><var>key</var><i>, const char *</i><var>salt</var><i>, struct crypt_data * </i><var>data</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>The <code>crypt_r</code> function does the same thing as <code>crypt</code>, but
takes an extra parameter which includes space for its result (among
other things), so it can be reentrant.  <code>data-&gt;initialized</code> must be
cleared to zero before the first time <code>crypt_r</code> is called.

     <p>The <code>crypt_r</code> function is a GNU extension. 
</td></tr>
</table>

   <p>The <code>crypt</code> and <code>crypt_r</code> functions are prototyped in the
header <code>crypt.h</code>.

   </body></html>

