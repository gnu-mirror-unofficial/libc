<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Miscellaneous%20Thread%20Functions">Miscellaneous Thread Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Streams-and-Fork.html#Streams%20and%20Fork">Streams and Fork</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="POSIX-Threads.html#POSIX%20Threads">POSIX Threads</a>
<hr><br>
</div>

<h3 class="section">Miscellaneous Thread Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">pthread_t <b>pthread_self</b><i> </i>(<i></i><var>void</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_self</code> returns the thread identifier for the calling thread. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_equal</b><i> </i>(<i>pthread_t thread1, pthread_t thread2</i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_equal</code> determines if two thread identifiers refer to the same
thread.

     <p>A non-zero value is returned if <var>thread1</var> and <var>thread2</var> refer to
the same thread. Otherwise, 0 is returned. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_detach</b><i> </i>(<i>pthread_t </i><var>th</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_detach</code> puts the thread <var>th</var> in the detached
state. This guarantees that the memory resources consumed by <var>th</var>
will be freed immediately when <var>th</var> terminates. However, this
prevents other threads from synchronizing on the termination of <var>th</var>
using <code>pthread_join</code>.

     <p>A thread can be created initially in the detached state, using the
<code>detachstate</code> attribute to <code>pthread_create</code>. In contrast,
<code>pthread_detach</code> applies to threads created in the joinable state,
and which need to be put in the detached state later.

     <p>After <code>pthread_detach</code> completes, subsequent attempts to perform
<code>pthread_join</code> on <var>th</var> will fail. If another thread is already
joining the thread <var>th</var> at the time <code>pthread_detach</code> is called,
<code>pthread_detach</code> does nothing and leaves <var>th</var> in the joinable
state.

     <p>On success, 0 is returned. On error, one of the following codes is
returned:
          <dl>
<dt><code>ESRCH</code>
          <dd>No thread could be found corresponding to that specified by <var>th</var>
<br><dt><code>EINVAL</code>
          <dd>The thread <var>th</var> is already in the detached state
</dl>
     </td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>pthread_kill_other_threads_np</b><i> </i>(<i></i><var>void</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_kill_other_threads_np</code> is a non-portable LinuxThreads extension. 
It causes all threads in the program to terminate immediately, except
the calling thread which proceeds normally. It is intended to be
called just before a thread calls one of the <code>exec</code> functions,
e.g. <code>execve</code>.

     <p>Termination of the other threads is not performed through
<code>pthread_cancel</code> and completely bypasses the cancellation
mechanism. Hence, the current settings for cancellation state and
cancellation type are ignored, and the cleanup handlers are not
executed in the terminated threads.

     <p>According to POSIX 1003.1c, a successful <code>exec*</code> in one of the
threads should automatically terminate all other threads in the program. 
This behavior is not yet implemented in LinuxThreads.  Calling
<code>pthread_kill_other_threads_np</code> before <code>exec*</code> achieves much
of the same behavior, except that if <code>exec*</code> ultimately fails, then
all other threads are already killed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_once</b><i> </i>(<i>pthread_once_t *once_</i><var>control</var><i>, void </i>(<i>*</i><var>init_routine</var><i></i>)<i> </i>(<i>void</i>)<i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>The purpose of <code>pthread_once</code> is to ensure that a piece of
initialization code is executed at most once. The <var>once_control</var>
argument points to a static or extern variable statically initialized
to <code>PTHREAD_ONCE_INIT</code>.

     <p>The first time <code>pthread_once</code> is called with a given
<var>once_control</var> argument, it calls <var>init_routine</var> with no
argument and changes the value of the <var>once_control</var> variable to
record that initialization has been performed. Subsequent calls to
<code>pthread_once</code> with the same <code>once_control</code> argument do
nothing.

     <p>If a thread is cancelled while executing <var>init_routine</var>
the state of the <var>once_control</var> variable is reset so that
a future call to <code>pthread_once</code> will call the routine again.

     <p>If the process forks while one or more threads are executing
<code>pthread_once</code> initialization routines, the states of their respective
<var>once_control</var> variables will appear to be reset in the child process so
that if the child calls <code>pthread_once</code>, the routines will be executed.

     <p><code>pthread_once</code> always returns 0. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_setschedparam</b><i> </i>(<i>pthread_t target_</i><var>thread</var><i>, int </i><var>policy</var><i>, const struct sched_param *</i><var>param</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>pthread_setschedparam</code> sets the scheduling parameters for the
thread <var>target_thread</var> as indicated by <var>policy</var> and
<var>param</var>. <var>policy</var> can be either <code>SCHED_OTHER</code> (regular,
non-realtime scheduling), <code>SCHED_RR</code> (realtime, round-robin) or
<code>SCHED_FIFO</code> (realtime, first-in first-out). <var>param</var> specifies
the scheduling priority for the two realtime policies.  See
<code>sched_setpolicy</code> for more information on scheduling policies.

     <p>The realtime scheduling policies <code>SCHED_RR</code> and <code>SCHED_FIFO</code>
are available only to processes with superuser privileges.

     <p>On success, <code>pthread_setschedparam</code> returns 0.  On error it returns
one of the following codes:
          <dl>
<dt><code>EINVAL</code>
          <dd><var>policy</var> is not one of <code>SCHED_OTHER</code>, <code>SCHED_RR</code>,
<code>SCHED_FIFO</code>, or the priority value specified by <var>param</var> is not
valid for the specified policy

          <br><dt><code>EPERM</code>
          <dd>Realtime scheduling was requested but the calling process does not have
sufficient privileges.

          <br><dt><code>ESRCH</code>
          <dd>The <var>target_thread</var> is invalid or has already terminated

          <br><dt><code>EFAULT</code>
          <dd><var>param</var> points outside the process memory space
</dl>
     </td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_getschedparam</b><i> </i>(<i>pthread_t target_</i><var>thread</var><i>, int *</i><var>policy</var><i>, struct sched_param *</i><var>param</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p><code>pthread_getschedparam</code> retrieves the scheduling policy and
scheduling parameters for the thread <var>target_thread</var> and stores them
in the locations pointed to by <var>policy</var> and <var>param</var>,
respectively.

     <p><code>pthread_getschedparam</code> returns 0 on success, or one of the
following error codes on failure:
          <dl>
<dt><code>ESRCH</code>
          <dd>The <var>target_thread</var> is invalid or has already terminated.

          <br><dt><code>EFAULT</code>
          <dd><var>policy</var> or <var>param</var> point outside the process memory space.

     </dl>
     </td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_setconcurrency</b><i> </i>(<i>int </i><var>level</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_setconcurrency</code> is unused in LinuxThreads due to the lack
of a mapping of user threads to kernel threads.  It exists for source
compatibility.  It does store the value <var>level</var> so that it can be
returned by a subsequent call to <code>pthread_getconcurrency</code>.  It takes
no other action however. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_getconcurrency</b><i> </i>(<i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_getconcurrency</code> is unused in LinuxThreads due to the lack
of a mapping of user threads to kernel threads.  It exists for source
compatibility.  However, it will return the value that was set by the
last call to <code>pthread_setconcurrency</code>. 
</td></tr>
</table>

   </body></html>

