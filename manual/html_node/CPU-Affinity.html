<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="CPU%20Affinity">CPU Affinity</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Traditional-Scheduling.html#Traditional%20Scheduling">Traditional Scheduling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Priority.html#Priority">Priority</a>
<hr><br>
</div>

<h3 class="subsection">Limiting execution to certain CPUs</h4>

<p>On a multi-processor system the operating system usually distributes
the different processes which are runnable on all available CPUs in a
way which allows the system to work most efficiently.  Which processes
and threads run can be to some extend be control with the scheduling
functionality described in the last sections.  But which CPU finally
executes which process or thread is not covered.

   <p>There are a number of reasons why a program might want to have control
over this aspect of the system as well:

     <ul>
<li>One thread or process is responsible for absolutely critical work
which under no circumstances must be interrupted or hindered from
making process by other process or threads using CPU resources.  In
this case the special process would be confined to a CPU which no
other process or thread is allowed to use.

     <li>The access to certain resources (RAM, I/O ports) has different costs
from different CPUs.  This is the case in NUMA (Non-Uniform Memory
Architecture) machines.  Preferrably memory should be accessed locally
but this requirement is usually not visible to the scheduler. 
Therefore forcing a process or thread to the CPUs which have local
access to the mostly used memory helps to significantly boost the
performance.

     <li>In controlled runtimes resource allocation and book-keeping work (for
instance garbage collection) is performance local to processors.  This
can help to reduce locking costs if the resources do not have to be
protected from concurrent accesses from different processors. 
</ul>

   <p>The POSIX standard up to this date is of not much help to solve this
problem.  The Linux kernel provides a set of interfaces to allow
specifying <em>affinity sets</em> for a process.  The scheduler will
schedule the thread or process on on CPUs specified by the affinity
masks.  The interfaces which the GNU C library define follow to some
extend the Linux kernel interface.

<p>
<table width="100%">
<tr>
<td align="left"><b>cpu_set_t</b><i>
     </i></td>
<td align="right">Data Type</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This data set is a bitset where each bit represents a CPU.  How the
system's CPUs are mapped to bits in the bitset is system dependent. 
The data type has a fixed size; in the unlikely case that the number
of bits are not sufficient to describe the CPUs of the system a
different interface has to be used.

     <p>This type is a GNU extension and is defined in <code>sched.h</code>. 
</td></tr>
</table>

   <p>To manipulate the bitset, to set and reset bits, a number of macros is
defined.  Some of the macros take a CPU number as a parameter.  Here
it is important to never exceed the size of the bitset.  The following
macro specifies the number of bits in the <code>cpu_set_t</code> bitset.

<p>
<table width="100%">
<tr>
<td align="left">int <b>CPU_SETSIZE</b><i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The value of this macro is the maximum number of CPUs which can be
handled with a <code>cpu_set_t</code> object. 
</td></tr>
</table>

   <p>The type <code>cpu_set_t</code> should be considered opaque; all
manipulation should happen via the next four macros.

<p>
<table width="100%">
<tr>
<td align="left">void <b>CPU_ZERO</b><i> </i>(<i>cpu_set_t *</i><var>set</var><i></i>)<i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This macro initializes the CPU set <var>set</var> to be the empty set.

     <p>This macro is a GNU extension and is defined in <code>sched.h</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>CPU_SET</b><i> </i>(<i>int </i><var>cpu</var><i>, cpu_set_t *</i><var>set</var><i></i>)<i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This macro adds <var>cpu</var> to the CPU set <var>set</var>.

     <p>The <var>cpu</var> parameter must not have side effects since it is
evaluated more than once.

     <p>This macro is a GNU extension and is defined in <code>sched.h</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>CPU_CLR</b><i> </i>(<i>int </i><var>cpu</var><i>, cpu_set_t *</i><var>set</var><i></i>)<i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This macro removes <var>cpu</var> from the CPU set <var>set</var>.

     <p>The <var>cpu</var> parameter must not have side effects since it is
evaluated more than once.

     <p>This macro is a GNU extension and is defined in <code>sched.h</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>CPU_ISSET</b><i> </i>(<i>int </i><var>cpu</var><i>, const cpu_set_t *</i><var>set</var><i></i>)<i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This macro returns a nonzero value (true) if <var>cpu</var> is a member
of the CPU set <var>set</var>, and zero (false) otherwise.

     <p>The <var>cpu</var> parameter must not have side effects since it is
evaluated more than once.

     <p>This macro is a GNU extension and is defined in <code>sched.h</code>. 
</td></tr>
</table>

   <p>CPU bitsets can be constructed from scratch or the currently installed
affinity mask can be retrieved from the system.

<p>
<table width="100%">
<tr>
<td align="left">int <b>sched_getaffinity</b><i> </i>(<i>pid_t </i><var>pid</var><i>, cpu_set_t *</i><var>cpuset</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>This functions stores the CPU affinity mask for the process or thread
with the ID <var>pid</var> in the memory pointed to by <var>cpuset</var>.  If
successful, the function always initializes all bits in the
<code>cpu_set_t</code> object and returns zero.

     <p>If <var>pid</var> does not correspond to a process or thread on the system
the or the function fails for some other reason, it returns <code>-1</code>
and <code>errno</code> is set to represent the error condition.

          <dl>
<dt><code>ESRCH</code>
          <dd>No process or thread with the given ID found.

          <br><dt><code>EFAULT</code>
          <dd>The pointer <var>cpuset</var> is does not point to a valid object. 
</dl>

     <p>This function is a GNU extension and is declared in <code>sched.h</code>. 
</td></tr>
</table>

   <p>Note that it is not portably possible to use this information to
retrieve the information for different POSIX threads.  A separate
interface must be provided for that.

<p>
<table width="100%">
<tr>
<td align="left">int <b>sched_setaffinity</b><i> </i>(<i>pid_t </i><var>pid</var><i>, const cpu_set_t *</i><var>cpuset</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>This function installs the affinity mask pointed to by <var>cpuset</var>
for the process or thread with the ID <var>pid</var>.  If successful the
function returns zero and the scheduler will in future take the
affinity information into account.

     <p>If the function fails it will return <code>-1</code> and <code>errno</code> is set
to the error code:

          <dl>
<dt><code>ESRCH</code>
          <dd>No process or thread with the given ID found.

          <br><dt><code>EFAULT</code>
          <dd>The pointer <var>cpuset</var> is does not point to a valid object.

          <br><dt><code>EINVAL</code>
          <dd>The bitset is not valid.  This might mean that the affinity set might
not leave a processor for the process or thread to run on. 
</dl>

     <p>This function is a GNU extension and is declared in <code>sched.h</code>. 
</td></tr>
</table>

   </body></html>

