<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Parsing%20of%20Integers">Parsing of Integers</a>,
Next:<a rel=next accesskey=n href="Parsing-of-Floats.html#Parsing%20of%20Floats">Parsing of Floats</a>,
Up:<a rel=up accesskey=u href="Parsing-of-Numbers.html#Parsing%20of%20Numbers">Parsing of Numbers</a>
<hr><br>

<h4>Parsing of Integers</h4>

<p>The <code>str</code> functions are declared in <code>stdlib.h</code> and those
beginning with <code>wcs</code> are declared in <code>wchar.h</code>.  One might
wonder about the use of <code>restrict</code> in the prototypes of the
functions in this section.  It is seemingly useless but the ISO&nbsp;C
standard uses it (for the functions defined there) so we have to do it
as well.

<p>
<table width="100%">
<tr>
<td align="left">long int <b>strtol</b><i> (const char *restrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strtol</code> ("string-to-long") function converts the initial
part of <var>string</var> to a signed integer, which is returned as a value
of type <code>long int</code>.

<p>This function attempts to decompose <var>string</var> as follows:

<ul>
<li>A (possibly empty) sequence of whitespace characters.  Which characters
are whitespace is determined by the <code>isspace</code> function
(see <a href="Classification-of-Characters.html#Classification%20of%20Characters">Classification of Characters</a>).  These are discarded.

<li>An optional plus or minus sign (<code>+</code> or <code>-</code>).

<li>A nonempty sequence of digits in the radix specified by <var>base</var>.

<p>If <var>base</var> is zero, decimal radix is assumed unless the series of
digits begins with <code>0</code> (specifying octal radix), or <code>0x</code> or
<code>0X</code> (specifying hexadecimal radix); in other words, the same
syntax used for integer constants in C.

<p>Otherwise <var>base</var> must have a value between <code>2</code> and <code>36</code>. 
If <var>base</var> is <code>16</code>, the digits may optionally be preceded by
<code>0x</code> or <code>0X</code>.  If base has no legal value the value returned
is <code>0l</code> and the global variable <code>errno</code> is set to <code>EINVAL</code>.

</p><li>Any remaining characters in the string.  If <var>tailptr</var> is not a null
pointer, <code>strtol</code> stores a pointer to this tail in
<code>*<var>tailptr</var></code>. 
</ul>

<p>If the string is empty, contains only whitespace, or does not contain an
initial substring that has the expected syntax for an integer in the
specified <var>base</var>, no conversion is performed.  In this case,
<code>strtol</code> returns a value of zero and the value stored in
<code>*<var>tailptr</var></code> is the value of <var>string</var>.

<p>In a locale other than the standard <code>"C"</code> locale, this function
may recognize additional implementation-dependent syntax.

<p>If the string has valid syntax for an integer but the value is not
representable because of overflow, <code>strtol</code> returns either
<code>LONG_MAX</code> or <code>LONG_MIN</code> (see <a href="Range-of-Type.html#Range%20of%20Type">Range of Type</a>), as
appropriate for the sign of the value.  It also sets <code>errno</code>
to <code>ERANGE</code> to indicate there was overflow.

<p>You should not check for errors by examining the return value of
<code>strtol</code>, because the string might be a valid representation of
<code>0l</code>, <code>LONG_MAX</code>, or <code>LONG_MIN</code>.  Instead, check whether
<var>tailptr</var> points to what you expect after the number
(e.g. <code>'\0'</code> if the string should end after the number).  You also
need to clear <var>errno</var> before the call and check it afterward, in
case there was overflow.

<p>There is an example at the end of this section. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long int <b>wcstol</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstol</code> function is equivalent to the <code>strtol</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstol</code> function was introduced in Amendment&nbsp;1 of ISO&nbsp;C90. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>strtoul</b><i> (const char *retrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strtoul</code> ("string-to-unsigned-long") function is like
<code>strtol</code> except it converts to an <code>unsigned long int</code> value. 
The syntax is the same as described above for <code>strtol</code>.  The value
returned on overflow is <code>ULONG_MAX</code> (see <a href="Range-of-Type.html#Range%20of%20Type">Range of Type</a>).

<p>If <var>string</var> depicts a negative number, <code>strtoul</code> acts the same
as <var>strtol</var> but casts the result to an unsigned integer.  That means
for example that <code>strtoul</code> on <code>"-1"</code> returns <code>ULONG_MAX</code>
and an input more negative than <code>LONG_MIN</code> returns
(<code>ULONG_MAX</code> + 1) / 2.

<p><code>strtoul</code> sets <var>errno</var> to <code>EINVAL</code> if <var>base</var> is out of
range, or <code>ERANGE</code> on overflow. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>wcstoul</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstoul</code> function is equivalent to the <code>strtoul</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstoul</code> function was introduced in Amendment&nbsp;1 of ISO&nbsp;C90. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long long int <b>strtoll</b><i> (const char *restrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strtoll</code> function is like <code>strtol</code> except that it returns
a <code>long long int</code> value, and accepts numbers with a correspondingly
larger range.

<p>If the string has valid syntax for an integer but the value is not
representable because of overflow, <code>strtoll</code> returns either
<code>LONG_LONG_MAX</code> or <code>LONG_LONG_MIN</code> (see <a href="Range-of-Type.html#Range%20of%20Type">Range of Type</a>), as
appropriate for the sign of the value.  It also sets <code>errno</code> to
<code>ERANGE</code> to indicate there was overflow.

<p>The <code>strtoll</code> function was introduced in ISO&nbsp;C99. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long long int <b>wcstoll</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstoll</code> function is equivalent to the <code>strtoll</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstoll</code> function was introduced in Amendment&nbsp;1 of ISO&nbsp;C90. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long long int <b>strtoq</b><i> (const char *restrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>strtoq</code> ("string-to-quad-word") is the BSD name for <code>strtoll</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long long int <b>wcstoq</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstoq</code> function is equivalent to the <code>strtoq</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstoq</code> function is a GNU extension. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long long int <b>strtoull</b><i> (const char *restrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strtoull</code> function is related to <code>strtoll</code> the same way
<code>strtoul</code> is related to <code>strtol</code>.

<p>The <code>strtoull</code> function was introduced in ISO&nbsp;C99. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long long int <b>wcstoull</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstoull</code> function is equivalent to the <code>strtoull</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstoull</code> function was introduced in Amendment&nbsp;1 of ISO&nbsp;C90. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long long int <b>strtouq</b><i> (const char *restrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>strtouq</code> is the BSD name for <code>strtoull</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long long int <b>wcstouq</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstouq</code> function is equivalent to the <code>strtouq</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstoq</code> function is a GNU extension. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">intmax_t <b>strtoimax</b><i> (const char *restrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strtoimax</code> function is like <code>strtol</code> except that it returns
a <code>intmax_t</code> value, and accepts numbers of a corresponding range.

<p>If the string has valid syntax for an integer but the value is not
representable because of overflow, <code>strtoimax</code> returns either
<code>INTMAX_MAX</code> or <code>INTMAX_MIN</code> (see <a href="Integers.html#Integers">Integers</a>), as
appropriate for the sign of the value.  It also sets <code>errno</code> to
<code>ERANGE</code> to indicate there was overflow.

<p>See <a href="Integers.html#Integers">Integers</a> for a description of the <code>intmax_t</code> type.  The
<code>strtoimax</code> function was introduced in ISO&nbsp;C99. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">intmax_t <b>wcstoimax</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstoimax</code> function is equivalent to the <code>strtoimax</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstoimax</code> function was introduced in ISO&nbsp;C99. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">uintmax_t <b>strtoumax</b><i> (const char *restrict <var>string</var>, char **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strtoumax</code> function is related to <code>strtoimax</code>
the same way that <code>strtoul</code> is related to <code>strtol</code>.

<p>See <a href="Integers.html#Integers">Integers</a> for a description of the <code>intmax_t</code> type.  The
<code>strtoumax</code> function was introduced in ISO&nbsp;C99. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">uintmax_t <b>wcstoumax</b><i> (const wchar_t *restrict <var>string</var>, wchar_t **restrict <var>tailptr</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcstoumax</code> function is equivalent to the <code>strtoumax</code> function
in nearly all aspects but handles wide character strings.

<p>The <code>wcstoumax</code> function was introduced in ISO&nbsp;C99. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long int <b>atol</b><i> (const char *<var>string</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is similar to the <code>strtol</code> function with a <var>base</var>
argument of <code>10</code>, except that it need not detect overflow errors. 
The <code>atol</code> function is provided mostly for compatibility with
existing code; using <code>strtol</code> is more robust. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>atoi</b><i> (const char *<var>string</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is like <code>atol</code>, except that it returns an <code>int</code>. 
The <code>atoi</code> function is also considered obsolete; use <code>strtol</code>
instead. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long long int <b>atoll</b><i> (const char *<var>string</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is similar to <code>atol</code>, except it returns a <code>long
long int</code>.

<p>The <code>atoll</code> function was introduced in ISO&nbsp;C99.  It too is
obsolete (despite having just been added); use <code>strtoll</code> instead. 
</td></tr>
</table>

<p>All the functions mentioned in this section so far do not handle
alternative representations of characters as described in the locale
data.  Some locales specify thousands separator and the way they have to
be used which can help to make large numbers more readable.  To read
such numbers one has to use the <code>scanf</code> functions with the <code>'</code>
flag.

<p>Here is a function which parses a string as a sequence of integers and
returns the sum of them:

<br><pre>int
sum_ints_from_string (char *string)
{
  int sum = 0;

  while (1) {
    char *tail;
    int next;

    /* Skip whitespace by hand, to detect the end.  */
    while (isspace (*string)) string++;
    if (*string == 0)
      break;

    /* There is more nonwhitespace,  */
    /* so it ought to be another number.  */
    errno = 0;
    /* Parse it.  */
    next = strtol (string, &amp;tail, 0);
    /* Add it in, if not overflow.  */
    if (errno)
      printf ("Overflow\n");
    else
      sum += next;
    /* Advance past it.  */
    string = tail;
  }

  return sum;
}
</pre>

</body></html>

