<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Mount-Unmount-Remount">Mount-Unmount-Remount</a>,
Previous:<a rel=previous accesskey=p href="Mount-Information.html#Mount%20Information">Mount Information</a>,
Up:<a rel=up accesskey=u href="Filesystem-Handling.html#Filesystem%20Handling">Filesystem Handling</a>
<hr><br>

<h4>Mount, Unmount, Remount</h4>

<p>This section describes the functions for mounting, unmounting, and
remounting filesystems.

<p>Only the superuser can mount, unmount, or remount a filesystem.

<p>These functions do not access the <code>fstab</code> and <code>mtab</code> files.  You
should maintain and use these separately.  See <a href="Mount-Information.html#Mount%20Information">Mount Information</a>.

<p>The symbols in this section are declared in <code>sys/mount.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">int <b>mount</b><i> (const char *<var>special_file</var>, const char *<var>dir</var>, const char *<var>fstype</var>, unsigned long int <var>options</var>, const void *<var>data</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<p><code>mount</code> mounts or remounts a filesystem.  The two operations are
quite different and are merged rather unnaturally into this one function. 
The <code>MS_REMOUNT</code> option, explained below, determines whether
<code>mount</code> mounts or remounts.

<p>For a mount, the filesystem on the block device represented by the
device special file named <var>special_file</var> gets mounted over the mount
point <var>dir</var>.  This means that the directory <var>dir</var> (along with any
files in it) is no longer visible; in its place (and still with the name
<var>dir</var>) is the root directory of the filesystem on the device.

<p>As an exception, if the filesystem type (see below) is one which is not
based on a device (e.g. "proc"), <code>mount</code> instantiates a
filesystem and mounts it over <var>dir</var> and ignores <var>special_file</var>.

<p>For a remount, <var>dir</var> specifies the mount point where the filesystem
to be remounted is (and remains) mounted and <var>special_file</var> is
ignored.  Remounting a filesystem means changing the options that control
operations on the filesystem while it is mounted.  It does not mean
unmounting and mounting again.

<p>For a mount, you must identify the type of the filesystem as
<var>fstype</var>.  This type tells the kernel how to access the filesystem
and can be thought of as the name of a filesystem driver.  The
acceptable values are system dependent.  On a system with a Linux kernel
and the <code>proc</code> filesystem, the list of possible values is in the
file <code>filesystems</code> in the <code>proc</code> filesystem (e.g. type
<kbd>cat /proc/filesystems</kbd> to see the list).  With a Linux kernel, the
types of filesystems that <code>mount</code> can mount, and their type names,
depends on what filesystem drivers are configured into the kernel or
loaded as loadable kernel modules.  An example of a common value for
<var>fstype</var> is <code>ext2</code>.

<p>For a remount, <code>mount</code> ignores <var>fstype</var>.

<p><var>options</var> specifies a variety of options that apply until the
filesystem is unmounted or remounted.  The precise meaning of an option
depends on the filesystem and with some filesystems, an option may have
no effect at all.  Furthermore, for some filesystems, some of these
options (but never <code>MS_RDONLY</code>) can be overridden for individual
file accesses via <code>ioctl</code>.

<p><var>options</var> is a bit string with bit fields defined using the
following mask and masked value macros:

<dl>
<dt><code>MS_MGC_MASK</code>
<dd>This multibit field contains a magic number.  If it does not have the value
<code>MS_MGC_VAL</code>, <code>mount</code> assumes all the following bits are zero and
the <var>data</var> argument is a null string, regardless of their actual values.

<br><dt><code>MS_REMOUNT</code>
<dd>This bit on means to remount the filesystem.  Off means to mount it.

<br><dt><code>MS_RDONLY</code>
<dd>This bit on specifies that no writing to the filesystem shall be allowed
while it is mounted.  This cannot be overridden by <code>ioctl</code>.  This
option is available on nearly all filesystems.

<br><dt><code>S_IMMUTABLE</code>
<dd>This bit on specifies that no writing to the files in the filesystem
shall be allowed while it is mounted.  This can be overridden for a
particular file access by a properly privileged call to <code>ioctl</code>. 
This option is a relatively new invention and is not available on many
filesystems.

<br><dt><code>S_APPEND</code>
<dd>This bit on specifies that the only file writing that shall be allowed
while the filesystem is mounted is appending.  Some filesystems allow
this to be overridden for a particular process by a properly privileged
call to <code>ioctl</code>.  This is a relatively new invention and is not
available on many filesystems.

<br><dt><code>MS_NOSUID</code>
<dd>This bit on specifies that Setuid and Setgid permissions on files in the
filesystem shall be ignored while it is mounted.

<br><dt><code>MS_NOEXEC</code>
<dd>This bit on specifies that no files in the filesystem shall be executed
while the filesystem is mounted.

<br><dt><code>MS_NODEV</code>
<dd>This bit on specifies that no device special files in the filesystem
shall be accessible while the filesystem is mounted.

<br><dt><code>MS_SYNCHRONOUS</code>
<dd>This bit on specifies that all writes to the filesystem while it is
mounted shall be synchronous; i.e. data shall be synced before each
write completes rather than held in the buffer cache.

<br><dt><code>MS_MANDLOCK</code>
<dd>This bit on specifies that mandatory locks on files shall be permitted while
the filesystem is mounted.

<br><dt><code>MS_NOATIME</code>
<dd>This bit on specifies that access times of files shall not be updated when
the files are accessed while the filesystem is mounted.

<br><dt><code>MS_NODIRATIME</code>
<dd>This bit on specifies that access times of directories shall not be updated
when the directories are accessed while the filesystem in mounted.

</dl>

<p>Any bits not covered by the above masks should be set off; otherwise,
results are undefined.

<p>The meaning of <var>data</var> depends on the filesystem type and is controlled
entirely by the filesystem driver in the kernel.

<p>Example:

<br><pre>#include &lt;sys/mount.h&gt;

mount("/dev/hdb", "/cdrom", MS_MGC_VAL | MS_RDONLY | MS_NOSUID, "");

mount("/dev/hda2", "/mnt", MS_MGC_VAL | MS_REMOUNT, "");
</pre>

<p>Appropriate arguments for <code>mount</code> are conventionally recorded in
the <code>fstab</code> table.  See <a href="Mount-Information.html#Mount%20Information">Mount Information</a>.

<p>The return value is zero if the mount or remount is successful.  Otherwise,
it is <code>-1</code> and <code>errno</code> is set appropriately.  The values of
<code>errno</code> are filesystem dependent, but here is a general list:

<dl>
<dt><code>EPERM</code>
<dd>The process is not superuser. 
<br><dt><code>ENODEV</code>
<dd>The file system type <var>fstype</var> is not known to the kernel. 
<br><dt><code>ENOTBLK</code>
<dd>The file <var>dev</var> is not a block device special file. 
<br><dt><code>EBUSY</code>
<dd>
<ul>

<li>The device is already mounted.

<li>The mount point is busy.  (E.g. it is some process' working directory or
has a filesystem mounted on it already).

<li>The request is to remount read-only, but there are files open for write. 
</ul>

<br><dt><code>EINVAL</code>
<dd>
<ul>

<li>A remount was attempted, but there is no filesystem mounted over the
specified mount point.

<li>The supposed filesystem has an invalid superblock.

</ul>

<br><dt><code>EACCES</code>
<dd>
<ul>

<li>The filesystem is inherently read-only (possibly due to a switch on the
device) and the process attempted to mount it read/write (by setting the
<code>MS_RDONLY</code> bit off).

<li><var>special_file</var> or <var>dir</var> is not accessible due to file permissions.

<li><var>special_file</var> is not accessible because it is in a filesystem that is
mounted with the <code>MS_NODEV</code> option.

</ul>

<br><dt><code>EM_FILE</code>
<dd>The table of dummy devices is full.  <code>mount</code> needs to create a
dummy device (aka "unnamed" device) if the filesystem being mounted is
not one that uses a device.

</dl>

</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>umount2</b><i> (const char *<var>file</var>, int <var>flags</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<p><code>umount2</code> unmounts a filesystem.

<p>You can identify the filesystem to unmount either by the device special
file that contains the filesystem or by the mount point.  The effect is
the same.  Specify either as the string <var>file</var>.

<p><var>flags</var> contains the one-bit field identified by the following
mask macro:

<dl>

<br><dt><code>MNT_FORCE</code>
<dd>This bit on means to force the unmounting even if the filesystem is
busy, by making it unbusy first.  If the bit is off and the filesystem is
busy, <code>umount2</code> fails with <code>errno</code> = <code>EBUSY</code>.  Depending
on the filesystem, this may override all, some, or no busy conditions.

</dl>

<p>All other bits in <var>flags</var> should be set to zero; otherwise, the result
is undefined.

<p>Example:

<br><pre>#include &lt;sys/mount.h&gt;

umount2("/mnt", MNT_FORCE);

umount2("/dev/hdd1", 0);
</pre>

<p>After the filesystem is unmounted, the directory that was the mount point
is visible, as are any files in it.

<p>As part of unmounting, <code>umount2</code> syncs the filesystem.

<p>If the unmounting is successful, the return value is zero.  Otherwise, it
is <code>-1</code> and <code>errno</code> is set accordingly:

<dl>
<dt><code>EPERM</code>
<dd>The process is not superuser. 
<br><dt><code>EBUSY</code>
<dd>The filesystem cannot be unmounted because it is busy.  E.g. it contains
a directory that is some process's working directory or a file that some
process has open.  With some filesystems in some cases, you can avoid
this failure with the <code>MNT_FORCE</code> option.

<br><dt><code>EINVAL</code>
<dd><var>file</var> validly refers to a file, but that file is neither a mount
point nor a device special file of a currently mounted filesystem.

</dl>

<p>This function is not available on all systems. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>umount</b><i> (const char *<var>file</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<p><code>umount</code> does the same thing as <code>umount2</code> with <var>flags</var> set
to zeroes.  It is more widely available than <code>umount2</code> but since it
lacks the possibility to forcefully unmount a filesystem is deprecated
when <code>umount2</code> is also available. 
</td></tr>
</table>

</body></html>

