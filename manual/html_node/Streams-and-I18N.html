<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Streams%20and%20I18N">Streams and I18N</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Simple-Output.html#Simple%20Output">Simple Output</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Streams-and-Threads.html#Streams%20and%20Threads">Streams and Threads</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="I-O-on-Streams.html#I%2fO%20on%20Streams">I/O on Streams</a>
<hr><br>
</div>

<h3 class="section">Streams in Internationalized Applications</h3>

<p>ISO&nbsp;C90 introduced the new type <code>wchar_t</code> to allow handling
larger character sets.  What was missing was a possibility to output
strings of <code>wchar_t</code> directly.  One had to convert them into
multibyte strings using <code>mbstowcs</code> (there was no <code>mbsrtowcs</code>
yet) and then use the normal stream functions.  While this is doable it
is very cumbersome since performing the conversions is not trivial and
greatly increases program complexity and size.

   <p>The Unix standard early on (I think in XPG4.2) introduced two additional
format specifiers for the <code>printf</code> and <code>scanf</code> families of
functions.  Printing and reading of single wide characters was made
possible using the <code>%C</code> specifier and wide character strings can be
handled with <code>%S</code>.  These modifiers behave just like <code>%c</code> and
<code>%s</code> only that they expect the corresponding argument to have the
wide character type and that the wide character and string are
transformed into/from multibyte strings before being used.

   <p>This was a beginning but it is still not good enough.  Not always is it
desirable to use <code>printf</code> and <code>scanf</code>.  The other, smaller and
faster functions cannot handle wide characters.  Second, it is not
possible to have a format string for <code>printf</code> and <code>scanf</code>
consisting of wide characters.  The result is that format strings would
have to be generated if they have to contain non-basic characters.

   <p>In the Amendment&nbsp;1 to ISO&nbsp;C90 a whole new set of functions was
added to solve the problem.  Most of the stream functions got a
counterpart which take a wide character or wide character string instead
of a character or string respectively.  The new functions operate on the
same streams (like <code>stdout</code>).  This is different from the model of
the C++ runtime library where separate streams for wide and normal I/O
are used.

   <p>Being able to use the same stream for wide and normal operations comes
with a restriction: a stream can be used either for wide operations or
for normal operations.  Once it is decided there is no way back.  Only a
call to <code>freopen</code> or <code>freopen64</code> can reset the
<dfn>orientation</dfn>.  The orientation can be decided in three ways:

     <ul>
<li>If any of the normal character functions is used (this includes the
<code>fread</code> and <code>fwrite</code> functions) the stream is marked as not
wide oriented.

     <li>If any of the wide character functions is used the stream is marked as
wide oriented.

     <li>The <code>fwide</code> function can be used to set the orientation either way. 
</ul>

   <p>It is important to never mix the use of wide and not wide operations on
a stream.  There are no diagnostics issued.  The application behavior
will simply be strange or the application will simply crash.  The
<code>fwide</code> function can help avoiding this.

<p>
<table width="100%">
<tr>
<td align="left">int <b>fwide</b><i> </i>(<i>FILE *</i><var>stream</var><i>, int </i><var>mode</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

     <p>The <code>fwide</code> function can be used to set and query the state of the
orientation of the stream <var>stream</var>.  If the <var>mode</var> parameter has
a positive value the streams get wide oriented, for negative values
narrow oriented.  It is not possible to overwrite previous orientations
with <code>fwide</code>.  I.e., if the stream <var>stream</var> was already
oriented before the call nothing is done.

     <p>If <var>mode</var> is zero the current orientation state is queried and
nothing is changed.

     <p>The <code>fwide</code> function returns a negative value, zero, or a positive
value if the stream is narrow, not at all, or wide oriented
respectively.

     <p>This function was introduced in Amendment&nbsp;1 to ISO&nbsp;C90 and is
declared in <code>wchar.h</code>. 
</td></tr>
</table>

   <p>It is generally a good idea to orient a stream as early as possible. 
This can prevent surprise especially for the standard streams
<code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.  If some library
function in some situations uses one of these streams and this use
orients the stream in a different way the rest of the application
expects it one might end up with hard to reproduce errors.  Remember
that no errors are signal if the streams are used incorrectly.  Leaving
a stream unoriented after creation is normally only necessary for
library functions which create streams which can be used in different
contexts.

   <p>When writing code which uses streams and which can be used in different
contexts it is important to query the orientation of the stream before
using it (unless the rules of the library interface demand a specific
orientation).  The following little, silly function illustrates this.

<pre class="smallexample">     void
     print_f (FILE *fp)
     {
       if (fwide (fp, 0) &gt; 0)
         /* Positive return value means wide orientation.  */
         fputwc (L'f', fp);
       else
         fputc ('f', fp);
     }
     </pre>

   <p>Note that in this case the function <code>print_f</code> decides about the
orientation of the stream if it was unoriented before (will not happen
if the advise above is followed).

   <p>The encoding used for the <code>wchar_t</code> values is unspecified and the
user must not make any assumptions about it.  For I/O of <code>wchar_t</code>
values this means that it is impossible to write these values directly
to the stream.  This is not what follows from the ISO&nbsp;C locale model
either.  What happens instead is that the bytes read from or written to
the underlying media are first converted into the internal encoding
chosen by the implementation for <code>wchar_t</code>.  The external encoding
is determined by the <code>LC_CTYPE</code> category of the current locale or
by the <code>ccs</code> part of the mode specification given to <code>fopen</code>,
<code>fopen64</code>, <code>freopen</code>, or <code>freopen64</code>.  How and when the
conversion happens is unspecified and it happens invisible to the user.

   <p>Since a stream is created in the unoriented state it has at that point
no conversion associated with it.  The conversion which will be used is
determined by the <code>LC_CTYPE</code> category selected at the time the
stream is oriented.  If the locales are changed at the runtime this
might produce surprising results unless one pays attention.  This is
just another good reason to orient the stream explicitly as soon as
possible, perhaps with a call to <code>fwide</code>.

   </body></html>

