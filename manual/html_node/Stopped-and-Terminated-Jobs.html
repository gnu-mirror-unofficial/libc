<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Stopped%20and%20Terminated%20Jobs">Stopped and Terminated Jobs</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Continuing-Stopped-Jobs.html#Continuing%20Stopped%20Jobs">Continuing Stopped Jobs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Foreground-and-Background.html#Foreground%20and%20Background">Foreground and Background</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Implementing-a-Shell.html#Implementing%20a%20Shell">Implementing a Shell</a>
<hr><br>
</div>

<h3 class="subsection">Stopped and Terminated Jobs</h4>

<p>When a foreground process is launched, the shell must block until all of
the processes in that job have either terminated or stopped.  It can do
this by calling the <code>waitpid</code> function; see <a href="Process-Completion.html#Process%20Completion">Process Completion</a>.  Use the <code>WUNTRACED</code> option so that status is reported
for processes that stop as well as processes that terminate.

   <p>The shell must also check on the status of background jobs so that it
can report terminated and stopped jobs to the user; this can be done by
calling <code>waitpid</code> with the <code>WNOHANG</code> option.  A good place to
put a such a check for terminated and stopped jobs is just before
prompting for a new command.

   <p>The shell can also receive asynchronous notification that there is
status information available for a child process by establishing a
handler for <code>SIGCHLD</code> signals.  See <a href="Signal-Handling.html#Signal%20Handling">Signal Handling</a>.

   <p>In the sample shell program, the <code>SIGCHLD</code> signal is normally
ignored.  This is to avoid reentrancy problems involving the global data
structures the shell manipulates.  But at specific times when the shell
is not using these data structures--such as when it is waiting for
input on the terminal--it makes sense to enable a handler for
<code>SIGCHLD</code>.  The same function that is used to do the synchronous
status checks (<code>do_job_notification</code>, in this case) can also be
called from within this handler.

   <p>Here are the parts of the sample shell program that deal with checking
the status of jobs and reporting the information to the user.

<pre class="smallexample">     /* Store the status of the process <var>pid</var> that was returned by waitpid.
        Return 0 if all went well, nonzero otherwise.  */
     
     int
     mark_process_status (pid_t pid, int status)
     {
       job *j;
       process *p;
     
       if (pid &gt; 0)
         {
           /* Update the record for the process.  */
           for (j = first_job; j; j = j-&gt;next)
             for (p = j-&gt;first_process; p; p = p-&gt;next)
               if (p-&gt;pid == pid)
                 {
                   p-&gt;status = status;
                   if (WIFSTOPPED (status))
                     p-&gt;stopped = 1;
                   else
                     {
                       p-&gt;completed = 1;
                       if (WIFSIGNALED (status))
                         fprintf (stderr, "%d: Terminated by signal %d.\n",
                                  (int) pid, WTERMSIG (p-&gt;status));
                     }
                   return 0;
                  }
           fprintf (stderr, "No child process %d.\n", pid);
           return -1;
         }
       else if (pid == 0 || errno == ECHILD)
         /* No processes ready to report.  */
         return -1;
       else {
         /* Other weird errors.  */
         perror ("waitpid");
         return -1;
       }
     }
     
     /* Check for processes that have status information available,
        without blocking.  */
     
     void
     update_status (void)
     {
       int status;
       pid_t pid;
     
       do
         pid = waitpid (WAIT_ANY, &amp;status, WUNTRACED|WNOHANG);
       while (!mark_process_status (pid, status));
     }
     
     /* Check for processes that have status information available,
        blocking until all processes in the given job have reported.  */
     
     void
     wait_for_job (job *j)
     {
       int status;
       pid_t pid;
     
       do
         pid = waitpid (WAIT_ANY, &amp;status, WUNTRACED);
       while (!mark_process_status (pid, status)
              &amp;&amp; !job_is_stopped (j)
              &amp;&amp; !job_is_completed (j));
     }
     
     /* Format information about job status for the user to look at.  */
     
     void
     format_job_info (job *j, const char *status)
     {
       fprintf (stderr, "%ld (%s): %s\n", (long)j-&gt;pgid, status, j-&gt;command);
     }
     
     /* Notify the user about stopped or terminated jobs.
        Delete terminated jobs from the active job list.  */
     
     void
     do_job_notification (void)
     {
       job *j, *jlast, *jnext;
       process *p;
     
       /* Update status information for child processes.  */
       update_status ();
     
       jlast = NULL;
       for (j = first_job; j; j = jnext)
         {
           jnext = j-&gt;next;
     
           /* If all processes have completed, tell the user the job has
              completed and delete it from the list of active jobs.  */
           if (job_is_completed (j)) {
             format_job_info (j, "completed");
             if (jlast)
               jlast-&gt;next = jnext;
             else
               first_job = jnext;
             free_job (j);
           }
     
           /* Notify the user about stopped jobs,
              marking them so that we won't do this more than once.  */
           else if (job_is_stopped (j) &amp;&amp; !j-&gt;notified) {
             format_job_info (j, "stopped");
             j-&gt;notified = 1;
             jlast = j;
           }
     
           /* Don't say anything about jobs that are still running.  */
           else
             jlast = j;
         }
     }
     </pre>

   </body></html>

