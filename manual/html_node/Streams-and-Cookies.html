<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Streams%20and%20Cookies">Streams and Cookies</a>,
Next:<a rel=next accesskey=n href="Hook-Functions.html#Hook%20Functions">Hook Functions</a>,
Up:<a rel=up accesskey=u href="Custom-Streams.html#Custom%20Streams">Custom Streams</a>
<hr><br>

<h5>Custom Streams and Cookies</h5>

<p>Inside every custom stream is a special object called the <dfn>cookie</dfn>. 
This is an object supplied by you which records where to fetch or store
the data read or written.  It is up to you to define a data type to use
for the cookie.  The stream functions in the library never refer
directly to its contents, and they don't even know what the type is;
they record its address with type <code>void *</code>.

<p>To implement a custom stream, you must specify <em>how</em> to fetch or
store the data in the specified place.  You do this by defining
<dfn>hook functions</dfn> to read, write, change "file position", and close
the stream.  All four of these functions will be passed the stream's
cookie so they can tell where to fetch or store the data.  The library
functions don't know what's inside the cookie, but your functions will
know.

<p>When you create a custom stream, you must specify the cookie pointer,
and also the four hook functions stored in a structure of type
<code>cookie_io_functions_t</code>.

<p>These facilities are declared in <code>stdio.h</code>.

<p>
<table width="100%">
<tr>
<td align="left"><b>cookie_io_functions_t</b><i>
</i></td>
<td align="right">Data Type</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This is a structure type that holds the functions that define the
communications protocol between the stream and its cookie.  It has
the following members:

<dl>
<dt><code>cookie_read_function_t *read</code>
<dd>This is the function that reads data from the cookie.  If the value is a
null pointer instead of a function, then read operations on this stream
always return <code>EOF</code>.

<br><dt><code>cookie_write_function_t *write</code>
<dd>This is the function that writes data to the cookie.  If the value is a
null pointer instead of a function, then data written to the stream is
discarded.

<br><dt><code>cookie_seek_function_t *seek</code>
<dd>This is the function that performs the equivalent of file positioning on
the cookie.  If the value is a null pointer instead of a function, calls
to <code>fseek</code> or <code>fseeko</code> on this stream can only seek to
locations within the buffer; any attempt to seek outside the buffer will
return an <code>ESPIPE</code> error.

<br><dt><code>cookie_close_function_t *close</code>
<dd>This function performs any appropriate cleanup on the cookie when
closing the stream.  If the value is a null pointer instead of a
function, nothing special is done to close the cookie when the stream is
closed. 
</dl>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">FILE * <b>fopencookie</b><i> (void *<var>cookie</var>, const char *<var>opentype</var>, cookie_io_functions_t <var>io-functions</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function actually creates the stream for communicating with the
<var>cookie</var> using the functions in the <var>io-functions</var> argument. 
The <var>opentype</var> argument is interpreted as for <code>fopen</code>;
see <a href="Opening-Streams.html#Opening%20Streams">Opening Streams</a>.  (But note that the "truncate on
open" option is ignored.)  The new stream is fully buffered.

<p>The <code>fopencookie</code> function returns the newly created stream, or a null
pointer in case of an error. 
</td></tr>
</table>

</body></html>

