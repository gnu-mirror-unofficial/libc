<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Exponents%20and%20Logarithms">Exponents and Logarithms</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Hyperbolic-Functions.html#Hyperbolic%20Functions">Hyperbolic Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Inverse-Trig-Functions.html#Inverse%20Trig%20Functions">Inverse Trig Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Mathematics.html#Mathematics">Mathematics</a>
<hr><br>
</div>

<h3 class="section">Exponentiation and Logarithms</h3>

<p>
<table width="100%">
<tr>
<td align="left">double <b>exp</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>expf</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>expl</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions compute <code>e</code> (the base of natural logarithms) raised
to the power <var>x</var>.

     <p>If the magnitude of the result is too large to be representable,
<code>exp</code> signals overflow. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>exp2</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>exp2f</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>exp2l</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions compute <code>2</code> raised to the power <var>x</var>. 
Mathematically, <code>exp2 (x)</code> is the same as <code>exp (x * log (2))</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>exp10</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>exp10f</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>exp10l</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">double <b>pow10</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>pow10f</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>pow10l</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions compute <code>10</code> raised to the power <var>x</var>. 
Mathematically, <code>exp10 (x)</code> is the same as <code>exp (x * log (10))</code>.

     <p>These functions are GNU extensions.  The name <code>exp10</code> is
preferred, since it is analogous to <code>exp</code> and <code>exp2</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>log</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>logf</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>logl</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions compute the natural logarithm of <var>x</var>.  <code>exp (log
(</code><var>x</var><code>))</code> equals <var>x</var>, exactly in mathematics and approximately in
C.

     <p>If <var>x</var> is negative, <code>log</code> signals a domain error.  If <var>x</var>
is zero, it returns negative infinity; if <var>x</var> is too close to zero,
it may signal overflow. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>log10</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>log10f</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>log10l</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return the base-10 logarithm of <var>x</var>. 
<code>log10 (</code><var>x</var><code>)</code> equals <code>log (</code><var>x</var><code>) / log (10)</code>.

        </td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>log2</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>log2f</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>log2l</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return the base-2 logarithm of <var>x</var>. 
<code>log2 (</code><var>x</var><code>)</code> equals <code>log (</code><var>x</var><code>) / log (2)</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>logb</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>logbf</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>logbl</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions extract the exponent of <var>x</var> and return it as a
floating-point value.  If <code>FLT_RADIX</code> is two, <code>logb</code> is equal
to <code>floor (log2 (x))</code>, except it's probably faster.

     <p>If <var>x</var> is de-normalized, <code>logb</code> returns the exponent <var>x</var>
would have if it were normalized.  If <var>x</var> is infinity (positive or
negative), <code>logb</code> returns &amp;infin;.  If <var>x</var> is zero,
<code>logb</code> returns &amp;infin;.  It does not signal. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>ilogb</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">int <b>ilogbf</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">int <b>ilogbl</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions are equivalent to the corresponding <code>logb</code>
functions except that they return signed integer values. 
</td></tr>
</table>

<p>Since integers cannot represent infinity and NaN, <code>ilogb</code> instead
returns an integer that can't be the exponent of a normal floating-point
number.  <code>math.h</code> defines constants so you can check for this.

<p>
<table width="100%">
<tr>
<td align="left">int <b>FP_ILOGB0</b><i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>ilogb</code> returns this value if its argument is <code>0</code>.  The
numeric value is either <code>INT_MIN</code> or <code>-INT_MAX</code>.

     <p>This macro is defined in ISO&nbsp;C99. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>FP_ILOGBNAN</b><i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>ilogb</code> returns this value if its argument is <code>NaN</code>.  The
numeric value is either <code>INT_MIN</code> or <code>INT_MAX</code>.

     <p>This macro is defined in ISO&nbsp;C99. 
</td></tr>
</table>

   <p>These values are system specific.  They might even be the same.  The
proper way to test the result of <code>ilogb</code> is as follows:

<pre class="smallexample">     i = ilogb (f);
     if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
       {
         if (isnan (f))
           {
             /* Handle NaN.  */
           }
         else if (f  == 0.0)
           {
             /* Handle 0.0.  */
           }
         else
           {
             /* Some other value with large exponent,
                perhaps +Inf.  */
           }
       }
     </pre>

<p>
<table width="100%">
<tr>
<td align="left">double <b>pow</b><i> </i>(<i>double </i><var>base</var><i>, double </i><var>power</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>powf</b><i> </i>(<i>float </i><var>base</var><i>, float </i><var>power</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>powl</b><i> </i>(<i>long double </i><var>base</var><i>, long double </i><var>power</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These are general exponentiation functions, returning <var>base</var> raised
to <var>power</var>.

     <p>Mathematically, <code>pow</code> would return a complex number when <var>base</var>
is negative and <var>power</var> is not an integral value.  <code>pow</code> can't
do that, so instead it signals a domain error. <code>pow</code> may also
underflow or overflow the destination type. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>sqrt</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>sqrtf</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>sqrtl</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return the nonnegative square root of <var>x</var>.

     <p>If <var>x</var> is negative, <code>sqrt</code> signals a domain error. 
Mathematically, it should return a complex number. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>cbrt</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>cbrtf</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>cbrtl</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return the cube root of <var>x</var>.  They cannot
fail; every representable real value has a representable real cube root. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>hypot</b><i> </i>(<i>double </i><var>x</var><i>, double </i><var>y</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>hypotf</b><i> </i>(<i>float </i><var>x</var><i>, float </i><var>y</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>hypotl</b><i> </i>(<i>long double </i><var>x</var><i>, long double </i><var>y</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return <code>sqrt (</code><var>x</var><code>*</code><var>x</var><code> +
</code><var>y</var><code>*</code><var>y</var><code>)</code>.  This is the length of the hypotenuse of a right
triangle with sides of length <var>x</var> and <var>y</var>, or the distance
of the point (<var>x</var>, <var>y</var>) from the origin.  Using this function
instead of the direct formula is wise, since the error is
much smaller.  See also the function <code>cabs</code> in <a href="Absolute-Value.html#Absolute%20Value">Absolute Value</a>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>expm1</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>expm1f</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>expm1l</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return a value equivalent to <code>exp (</code><var>x</var><code>) - 1</code>. 
They are computed in a way that is accurate even if <var>x</var> is
near zero--a case where <code>exp (</code><var>x</var><code>) - 1</code> would be inaccurate owing
to subtraction of two numbers that are nearly equal. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>log1p</b><i> </i>(<i>double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">float <b>log1pf</b><i> </i>(<i>float </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">long double <b>log1pl</b><i> </i>(<i>long double </i><var>x</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions returns a value equivalent to <code>log&nbsp;(1&nbsp;+&nbsp;</code><var>x</var><code>)</code>. 
They are computed in a way that is accurate even if <var>x</var> is
near zero. 
</td></tr>
</table>

   <p>ISO&nbsp;C99 defines complex variants of some of the exponentiation and
logarithm functions.

<p>
<table width="100%">
<tr>
<td align="left">complex double <b>cexp</b><i> </i>(<i>complex double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex float <b>cexpf</b><i> </i>(<i>complex float </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex long double <b>cexpl</b><i> </i>(<i>complex long double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return <code>e</code> (the base of natural
logarithms) raised to the power of <var>z</var>. 
Mathematically, this corresponds to the value

     <p>exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">complex double <b>clog</b><i> </i>(<i>complex double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex float <b>clogf</b><i> </i>(<i>complex float </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex long double <b>clogl</b><i> </i>(<i>complex long double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return the natural logarithm of <var>z</var>. 
Mathematically, this corresponds to the value

     <p>log (z) = log (cabs (z)) + I * carg (z)

     <p><code>clog</code> has a pole at 0, and will signal overflow if <var>z</var> equals
or is very close to 0.  It is well-defined for all other values of
<var>z</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">complex double <b>clog10</b><i> </i>(<i>complex double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex float <b>clog10f</b><i> </i>(<i>complex float </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex long double <b>clog10l</b><i> </i>(<i>complex long double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return the base 10 logarithm of the complex value
<var>z</var>. Mathematically, this corresponds to the value

     <p>log (z) = log10 (cabs (z)) + I * carg (z)

     <p>These functions are GNU extensions. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">complex double <b>csqrt</b><i> </i>(<i>complex double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex float <b>csqrtf</b><i> </i>(<i>complex float </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex long double <b>csqrtl</b><i> </i>(<i>complex long double </i><var>z</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return the complex square root of the argument <var>z</var>.  Unlike
the real-valued functions, they are defined for all values of <var>z</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">complex double <b>cpow</b><i> </i>(<i>complex double </i><var>base</var><i>, complex double </i><var>power</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex float <b>cpowf</b><i> </i>(<i>complex float </i><var>base</var><i>, complex float </i><var>power</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">complex long double <b>cpowl</b><i> </i>(<i>complex long double </i><var>base</var><i>, complex long double </i><var>power</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions return <var>base</var> raised to the power of
<var>power</var>.  This is equivalent to <code>cexp&nbsp;(y&nbsp;*&nbsp;clog&nbsp;(x))</code>
</td></tr>
</table>

   </body></html>

