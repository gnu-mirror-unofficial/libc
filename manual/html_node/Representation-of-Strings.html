<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Representation%20of%20Strings">Representation of Strings</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="String-Array-Conventions.html#String%2fArray%20Conventions">String/Array Conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="String-and-Array-Utilities.html#String%20and%20Array%20Utilities">String and Array Utilities</a>
<hr><br>
</div>

<h3 class="section">Representation of Strings</h3>

<p>This section is a quick summary of string concepts for beginning C
programmers.  It describes how character strings are represented in C
and some common pitfalls.  If you are already familiar with this
material, you can skip this section.

   <p>A <dfn>string</dfn> is an array of <code>char</code> objects.  But string-valued
variables are usually declared to be pointers of type <code>char *</code>. 
Such variables do not include space for the text of a string; that has
to be stored somewhere else--in an array variable, a string constant,
or dynamically allocated memory (see <a href="Memory-Allocation.html#Memory%20Allocation">Memory Allocation</a>).  It's up to
you to store the address of the chosen memory space into the pointer
variable.  Alternatively you can store a <dfn>null pointer</dfn> in the
pointer variable.  The null pointer does not point anywhere, so
attempting to reference the string it points to gets an error.

   <p>"string" normally refers to multibyte character strings as opposed to
wide character strings.  Wide character strings are arrays of type
<code>wchar_t</code> and as for multibyte character strings usually pointers
of type <code>wchar_t *</code> are used.

   <p>By convention, a <dfn>null character</dfn>, <code>'\0'</code>, marks the end of a
multibyte character string and the <dfn>null wide character</dfn>,
<code>L'\0'</code>, marks the end of a wide character string.  For example, in
testing to see whether the <code>char *</code> variable <var>p</var> points to a
null character marking the end of a string, you can write
<code>!*</code><var>p</var><code></code> or <code>*</code><var>p</var><code> == '\0'</code>.

   <p>A null character is quite different conceptually from a null pointer,
although both are represented by the integer <code>0</code>.

   <p><dfn>String literals</dfn> appear in C program source as strings of
characters between double-quote characters (<code>"</code>) where the initial
double-quote character is immediately preceded by a capital <code>L</code>
(ell) character (as in <code>L"foo"</code>).  In ISO&nbsp;C, string literals
can also be formed by <dfn>string concatenation</dfn>: <code>"a" "b"</code> is the
same as <code>"ab"</code>.  For wide character strings one can either use
<code>L"a" L"b"</code> or <code>L"a" "b"</code>.  Modification of string literals is
not allowed by the GNU C compiler, because literals are placed in
read-only storage.

   <p>Character arrays that are declared <code>const</code> cannot be modified
either.  It's generally good style to declare non-modifiable string
pointers to be of type <code>const char *</code>, since this often allows the
C compiler to detect accidental modifications as well as providing some
amount of documentation about what your program intends to do with the
string.

   <p>The amount of memory allocated for the character array may extend past
the null character that normally marks the end of the string.  In this
document, the term <dfn>allocated size</dfn> is always used to refer to the
total amount of memory allocated for the string, while the term
<dfn>length</dfn> refers to the number of characters up to (but not
including) the terminating null character.

   <p>A notorious source of program bugs is trying to put more characters in a
string than fit in its allocated size.  When writing code that extends
strings or moves characters into a pre-allocated array, you should be
very careful to keep track of the length of the text and make explicit
checks for overflowing the array.  Many of the library functions
<em>do not</em> do this for you!  Remember also that you need to allocate
an extra byte to hold the null character that marks the end of the
string.

   <p>Originally strings were sequences of bytes where each byte represents a
single character.  This is still true today if the strings are encoded
using a single-byte character encoding.  Things are different if the
strings are encoded using a multibyte encoding (for more information on
encodings see <a href="Extended-Char-Intro.html#Extended%20Char%20Intro">Extended Char Intro</a>).  There is no difference in
the programming interface for these two kind of strings; the programmer
has to be aware of this and interpret the byte sequences accordingly.

   <p>But since there is no separate interface taking care of these
differences the byte-based string functions are sometimes hard to use. 
Since the count parameters of these functions specify bytes a call to
<code>strncpy</code> could cut a multibyte character in the middle and put an
incomplete (and therefore unusable) byte sequence in the target buffer.

   <p>To avoid these problems later versions of the ISO&nbsp;C standard
introduce a second set of functions which are operating on <dfn>wide
characters</dfn> (see <a href="Extended-Char-Intro.html#Extended%20Char%20Intro">Extended Char Intro</a>).  These functions don't have
the problems the single-byte versions have since every wide character is
a legal, interpretable value.  This does not mean that cutting wide
character strings at arbitrary points is without problems.  It normally
is for alphabet-based languages (except for non-normalized text) but
languages based on syllables still have the problem that more than one
wide character is necessary to complete a logical unit.  This is a
higher level problem which the C&nbsp;library functions are not designed
to solve.  But it is at least good that no invalid byte sequences can be
created.  Also, the higher level functions can also much easier operate
on wide character than on multibyte characters so that a general advise
is to use wide characters internally whenever text is more than simply
copied.

   <p>The remaining of this chapter will discuss the functions for handling
wide character strings in parallel with the discussion of the multibyte
character strings since there is almost always an exact equivalent
available.

   </body></html>

