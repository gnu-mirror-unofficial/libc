<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Thread-Specific%20Data">Thread-Specific Data</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Threads-and-Signal-Handling.html#Threads%20and%20Signal%20Handling">Threads and Signal Handling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="POSIX-Semaphores.html#POSIX%20Semaphores">POSIX Semaphores</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="POSIX-Threads.html#POSIX%20Threads">POSIX Threads</a>
<hr><br>
</div>

<h3 class="section">Thread-Specific Data</h3>

<p>Programs often need global or static variables that have different
values in different threads. Since threads share one memory space, this
cannot be achieved with regular variables. Thread-specific data is the
POSIX threads answer to this need.

   <p>Each thread possesses a private memory block, the thread-specific data
area, or TSD area for short. This area is indexed by TSD keys. The TSD
area associates values of type <code>void *</code> to TSD keys. TSD keys are
common to all threads, but the value associated with a given TSD key can
be different in each thread.

   <p>For concreteness, the TSD areas can be viewed as arrays of <code>void *</code>
pointers, TSD keys as integer indices into these arrays, and the value
of a TSD key as the value of the corresponding array element in the
calling thread.

   <p>When a thread is created, its TSD area initially associates <code>NULL</code>
with all keys.

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_key_create</b><i> </i>(<i>pthread_key_t *</i><var>key</var><i>, void </i>(<i>*destr_function</i>)<i> </i>(<i>void *</i>)<i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_key_create</code> allocates a new TSD key. The key is stored in
the location pointed to by <var>key</var>. There is a limit of
<code>PTHREAD_KEYS_MAX</code> on the number of keys allocated at a given
time. The value initially associated with the returned key is
<code>NULL</code> in all currently executing threads.

     <p>The <var>destr_function</var> argument, if not <code>NULL</code>, specifies a
destructor function associated with the key. When a thread terminates
via <code>pthread_exit</code> or by cancellation, <var>destr_function</var> is
called on the value associated with the key in that thread. The
<var>destr_function</var> is not called if a key is deleted with
<code>pthread_key_delete</code> or a value is changed with
<code>pthread_setspecific</code>.  The order in which destructor functions are
called at thread termination time is unspecified.

     <p>Before the destructor function is called, the <code>NULL</code> value is
associated with the key in the current thread.  A destructor function
might, however, re-associate non-<code>NULL</code> values to that key or some
other key.  To deal with this, if after all the destructors have been
called for all non-<code>NULL</code> values, there are still some
non-<code>NULL</code> values with associated destructors, then the process is
repeated.  The LinuxThreads implementation stops the process after
<code>PTHREAD_DESTRUCTOR_ITERATIONS</code> iterations, even if some
non-<code>NULL</code> values with associated descriptors remain.  Other
implementations may loop indefinitely.

     <p><code>pthread_key_create</code> returns 0 unless <code>PTHREAD_KEYS_MAX</code> keys
have already been allocated, in which case it fails and returns
<code>EAGAIN</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_key_delete</b><i> </i>(<i>pthread_key_t </i><var>key</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_key_delete</code> deallocates a TSD key. It does not check
whether non-<code>NULL</code> values are associated with that key in the
currently executing threads, nor call the destructor function associated
with the key.

     <p>If there is no such key <var>key</var>, it returns <code>EINVAL</code>.  Otherwise
it returns 0. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>pthread_setspecific</b><i> </i>(<i>pthread_key_t </i><var>key</var><i>, const void *</i><var>pointer</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_setspecific</code> changes the value associated with <var>key</var>
in the calling thread, storing the given <var>pointer</var> instead.

     <p>If there is no such key <var>key</var>, it returns <code>EINVAL</code>.  Otherwise
it returns 0. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void * <b>pthread_getspecific</b><i> </i>(<i>pthread_key_t </i><var>key</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>pthread_getspecific</code> returns the value currently associated with
<var>key</var> in the calling thread.

     <p>If there is no such key <var>key</var>, it returns <code>NULL</code>. 
</td></tr>
</table>

   <p>The following code fragment allocates a thread-specific array of 100
characters, with automatic reclaimation at thread exit:

<pre class="smallexample">     /* Key for the thread-specific buffer */
     static pthread_key_t buffer_key;
     
     /* Once-only initialisation of the key */
     static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;
     
     /* Allocate the thread-specific buffer */
     void buffer_alloc(void)
     {
       pthread_once(&amp;buffer_key_once, buffer_key_alloc);
       pthread_setspecific(buffer_key, malloc(100));
     }
     
     /* Return the thread-specific buffer */
     char * get_buffer(void)
     {
       return (char *) pthread_getspecific(buffer_key);
     }
     
     /* Allocate the key */
     static void buffer_key_alloc()
     {
       pthread_key_create(&amp;buffer_key, buffer_destroy);
     }
     
     /* Free the thread-specific buffer */
     static void buffer_destroy(void * buf)
     {
       free(buf);
     }
     </pre>

   </body></html>

