<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Infinity%20and%20NaN">Infinity and NaN</a>,
Next:<a rel=next accesskey=n href="Status-bit-operations.html#Status%20bit%20operations">Status bit operations</a>,
Previous:<a rel=previous accesskey=p href="FP-Exceptions.html#FP%20Exceptions">FP Exceptions</a>,
Up:<a rel=up accesskey=u href="Floating-Point-Errors.html#Floating%20Point%20Errors">Floating Point Errors</a>
<hr><br>

<h4>Infinity and NaN</h4>

<p>IEEE&nbsp;754 floating point numbers can represent positive or negative
infinity, and <dfn>NaN</dfn> (not a number).  These three values arise from
calculations whose result is undefined or cannot be represented
accurately.  You can also deliberately set a floating-point variable to
any of them, which is sometimes useful.  Some examples of calculations
that produce infinity or NaN:

<br><pre>1/0 = &amp;infin;
log (0) = -&amp;infin;
sqrt (-1) = NaN
</pre>

<p>When a calculation produces any of these values, an exception also
occurs; see <a href="FP-Exceptions.html#FP%20Exceptions">FP Exceptions</a>.

<p>The basic operations and math functions all accept infinity and NaN and
produce sensible output.  Infinities propagate through calculations as
one would expect: for example, 2 + &amp;infin; = &amp;infin;,
4/&amp;infin; = 0, atan (&amp;infin;) = &amp;pi;/2.  NaN, on
the other hand, infects any calculation that involves it.  Unless the
calculation would produce the same result no matter what real value
replaced NaN, the result is NaN.

<p>In comparison operations, positive infinity is larger than all values
except itself and NaN, and negative infinity is smaller than all values
except itself and NaN.  NaN is <dfn>unordered</dfn>: it is not equal to,
greater than, or less than anything, <em>including itself</em>. <code>x ==
x</code> is false if the value of <code>x</code> is NaN.  You can use this to test
whether a value is NaN or not, but the recommended way to test for NaN
is with the <code>isnan</code> function (see <a href="Floating-Point-Classes.html#Floating%20Point%20Classes">Floating Point Classes</a>).  In
addition, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> will raise an
exception when applied to NaNs.

<p><code>math.h</code> defines macros that allow you to explicitly set a variable
to infinity or NaN.

<p>
<table width="100%">
<tr>
<td align="left">float <b>INFINITY</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
An expression representing positive infinity.  It is equal to the value
produced  by mathematical operations like <code>1.0 / 0.0</code>. 
<code>-INFINITY</code> represents negative infinity.

<p>You can test whether a floating-point value is infinite by comparing it
to this macro.  However, this is not recommended; you should use the
<code>isfinite</code> macro instead.  See <a href="Floating-Point-Classes.html#Floating%20Point%20Classes">Floating Point Classes</a>.

<p>This macro was introduced in the ISO&nbsp;C99 standard. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">float <b>NAN</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
An expression representing a value which is "not a number".  This
macro is a GNU extension, available only on machines that support the
"not a number" value--that is to say, on all machines that support
IEEE floating point.

<p>You can use <code>#ifdef NAN</code> to test whether the machine supports
NaN.  (Of course, you must arrange for GNU extensions to be visible,
such as by defining <code>_GNU_SOURCE</code>, and then you must include
<code>math.h</code>.) 
</td></tr>
</table>

<p>IEEE&nbsp;754 also allows for another unusual value: negative zero.  This
value is produced when you divide a positive number by negative
infinity, or when a negative result is smaller than the limits of
representation.  Negative zero behaves identically to zero in all
calculations, unless you explicitly test the sign bit with
<code>signbit</code> or <code>copysign</code>.

</body></html>

