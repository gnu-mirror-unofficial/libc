<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Allocation">Allocation</a>,
Next:<a rel=next accesskey=n href="Pseudo-Terminal-Pairs.html#Pseudo-Terminal%20Pairs">Pseudo-Terminal Pairs</a>,
Up:<a rel=up accesskey=u href="Pseudo-Terminals.html#Pseudo-Terminals">Pseudo-Terminals</a>
<hr><br>

<h4>Allocating Pseudo-Terminals</h4>

<p>This subsection describes functions for allocating a pseudo-terminal,
and for making this pseudo-terminal available for actual use.  These
functions are declared in the header file <code>stdlib.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">int <b>getpt</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>getpt</code> function returns a new file descriptor for the next
available master pseudo-terminal.  The normal return value from
<code>getpt</code> is a non-negative integer file descriptor.  In the case of
an error, a value of -1 is returned instead.  The following
<code>errno</code> conditions are defined for this function:

<dl>
<dt><code>ENOENT</code>
<dd>There are no free master pseudo-terminals available. 
</dl>

<p>This function is a GNU extension. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>grantpt</b><i> (int <var>filedes</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>grantpt</code> function changes the ownership and access permission
of the slave pseudo-terminal device corresponding to the master
pseudo-terminal device associated with the file descriptor
<var>filedes</var>.  The owner is set from the real user ID of the calling
process (see <a href="Process-Persona.html#Process%20Persona">Process Persona</a>), and the group is set to a special
group (typically <dfn>tty</dfn>) or from the real group ID of the calling
process.  The access permission is set such that the file is both
readable and writable by the owner and only writable by the group.

<p>On some systems this function is implemented by invoking a special
<code>setuid</code> root program (see <a href="How-Change-Persona.html#How%20Change%20Persona">How Change Persona</a>).  As a
consequence, installing a signal handler for the <code>SIGCHLD</code> signal
(see <a href="Job-Control-Signals.html#Job%20Control%20Signals">Job Control Signals</a>) may interfere with a call to
<code>grantpt</code>.

<p>The normal return value from <code>grantpt</code> is 0; a value of
-1 is returned in case of failure.  The following <code>errno</code>
error conditions are defined for this function:

<dl>
<dt><code>EBADF</code>
<dd>The <var>filedes</var> argument is not a valid file descriptor.

<br><dt><code>EINVAL</code>
<dd>The <var>filedes</var> argument is not associated with a master pseudo-terminal
device.

<br><dt><code>EACCES</code>
<dd>The slave pseudo-terminal device corresponding to the master associated
with <var>filedes</var> could not be accessed. 
</dl>

</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>unlockpt</b><i> (int <var>filedes</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>unlockpt</code> function unlocks the slave pseudo-terminal device
corresponding to the master pseudo-terminal device associated with the
file descriptor <var>filedes</var>.  On many systems, the slave can only be
opened after unlocking, so portable applications should always call
<code>unlockpt</code> before trying to open the slave.

<p>The normal return value from <code>unlockpt</code> is 0; a value of
-1 is returned in case of failure.  The following <code>errno</code>
error conditions are defined for this function:

<dl>
<dt><code>EBADF</code>
<dd>The <var>filedes</var> argument is not a valid file descriptor.

<br><dt><code>EINVAL</code>
<dd>The <var>filedes</var> argument is not associated with a master pseudo-terminal
device. 
</dl>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>ptsname</b><i> (int <var>filedes</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
If the file descriptor <var>filedes</var> is associated with a
master pseudo-terminal device, the <code>ptsname</code> function returns a
pointer to a statically-allocated, null-terminated string containing the
file name of the associated slave pseudo-terminal file.  This string
might be overwritten by subsequent calls to <code>ptsname</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>ptsname_r</b><i> (int <var>filedes</var>, char *<var>buf</var>, size_t <var>len</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>ptsname_r</code> function is similar to the <code>ptsname</code> function
except that it places its result into the user-specified buffer starting
at <var>buf</var> with length <var>len</var>.

<p>This function is a GNU extension. 
</td></tr>
</table>

<p><strong>Portability Note:</strong> On System&nbsp;V derived systems, the file
returned by the <code>ptsname</code> and <code>ptsname_r</code> functions may be
STREAMS-based, and therefore require additional processing after opening
before it actually behaves as a pseudo terminal.

<p>Typical usage of these functions is illustrated by the following example:
<br><pre>int
open_pty_pair (int *amaster, int *aslave)
{
  int master, slave;
  char *name;

  master = getpt ();
  if (master &lt; 0)
    return 0;

  if (grantpt (master) &lt; 0 || unlockpt (master) &lt; 0)
    goto close_master;
  name = ptsname (master);
  if (name == NULL)
    goto close_master;

  slave = open (name, O_RDWR);
  if (slave == -1)
    goto close_master;

  if (isastream (slave))
    {
      if (ioctl (slave, I_PUSH, "ptem") &lt; 0
          || ioctl (slave, I_PUSH, "ldterm") &lt; 0)
        goto close_slave;
    }

  *amaster = master;
  *aslave = slave;
  return 1;

close_slave:
  close (slave);

close_master:
  close (master);
  return 0;
}
</pre>

</body></html>

