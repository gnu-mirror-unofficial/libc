<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Symbolic%20Links">Symbolic Links</a>,
Next:<a rel=next accesskey=n href="Deleting-Files.html#Deleting%20Files">Deleting Files</a>,
Previous:<a rel=previous accesskey=p href="Hard-Links.html#Hard%20Links">Hard Links</a>,
Up:<a rel=up accesskey=u href="File-System-Interface.html#File%20System%20Interface">File System Interface</a>
<hr><br>

<h3>Symbolic Links</h3>

<p>The GNU system supports <dfn>soft links</dfn> or <dfn>symbolic links</dfn>.  This
is a kind of "file" that is essentially a pointer to another file
name.  Unlike hard links, symbolic links can be made to directories or
across file systems with no restrictions.  You can also make a symbolic
link to a name which is not the name of any file.  (Opening this link
will fail until a file by that name is created.)  Likewise, if the
symbolic link points to an existing file which is later deleted, the
symbolic link continues to point to the same file name even though the
name no longer names any file.

<p>The reason symbolic links work the way they do is that special things
happen when you try to open the link.  The <code>open</code> function realizes
you have specified the name of a link, reads the file name contained in
the link, and opens that file name instead.  The <code>stat</code> function
likewise operates on the file that the symbolic link points to, instead
of on the link itself.

<p>By contrast, other operations such as deleting or renaming the file
operate on the link itself.  The functions <code>readlink</code> and
<code>lstat</code> also refrain from following symbolic links, because their
purpose is to obtain information about the link.  <code>link</code>, the
function that makes a hard link, does too.  It makes a hard link to the
symbolic link, which one rarely wants.

<p>Some systems have for some functions operating on files have a limit on
how many symbolic links are followed when resolving a path name.  The
limit if it exists is published in the <code>sys/param.h</code> header file.

<p>
<table width="100%">
<tr>
<td align="left">int <b>MAXSYMLINKS</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<p>The macro <code>MAXSYMLINKS</code> specifies how many symlinks some function
will follow before returning <code>ELOOP</code>.  Not all functions behave the
same and this value is not the same a that returned for
<code>_SC_SYMLOOP</code> by <code>sysconf</code>.  In fact, the <code>sysconf</code>
result can indicate that there is no fixed limit although
<code>MAXSYMLINKS</code> exists and has a finite value. 
</td></tr>
</table>

<p>Prototypes for most of the functions listed in this section are in
<code>unistd.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">int <b>symlink</b><i> (const char *<var>oldname</var>, const char *<var>newname</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>symlink</code> function makes a symbolic link to <var>oldname</var> named
<var>newname</var>.

<p>The normal return value from <code>symlink</code> is <code>0</code>.  A return value
of <code>-1</code> indicates an error.  In addition to the usual file name
syntax errors (see <a href="File-Name-Errors.html#File%20Name%20Errors">File Name Errors</a>), the following <code>errno</code>
error conditions are defined for this function:

<dl>
<dt><code>EEXIST</code>
<dd>There is already an existing file named <var>newname</var>.

<br><dt><code>EROFS</code>
<dd>The file <var>newname</var> would exist on a read-only file system.

<br><dt><code>ENOSPC</code>
<dd>The directory or file system cannot be extended to make the new link.

<br><dt><code>EIO</code>
<dd>A hardware error occurred while reading or writing data on the disk.

</dl>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>readlink</b><i> (const char *<var>filename</var>, char *<var>buffer</var>, size_t <var>size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>readlink</code> function gets the value of the symbolic link
<var>filename</var>.  The file name that the link points to is copied into
<var>buffer</var>.  This file name string is <em>not</em> null-terminated;
<code>readlink</code> normally returns the number of characters copied.  The
<var>size</var> argument specifies the maximum number of characters to copy,
usually the allocation size of <var>buffer</var>.

<p>If the return value equals <var>size</var>, you cannot tell whether or not
there was room to return the entire name.  So make a bigger buffer and
call <code>readlink</code> again.  Here is an example:

<br><pre>char *
readlink_malloc (const char *filename)
{
  int size = 100;

  while (1)
    {
      char *buffer = (char *) xmalloc (size);
      int nchars = readlink (filename, buffer, size);
      if (nchars &lt; 0)
        return NULL;
      if (nchars &lt; size)
        return buffer;
      free (buffer);
      size *= 2;
    }
}
</pre>

<p>A value of <code>-1</code> is returned in case of error.  In addition to the
usual file name errors (see <a href="File-Name-Errors.html#File%20Name%20Errors">File Name Errors</a>), the following
<code>errno</code> error conditions are defined for this function:

<dl>
<dt><code>EINVAL</code>
<dd>The named file is not a symbolic link.

<br><dt><code>EIO</code>
<dd>A hardware error occurred while reading or writing data on the disk. 
</dl>
</td></tr>
</table>

<p>In some situations it is desirable to resolve all the to get the real
name of a file where no prefix names a symbolic link which is followed
and no filename in the path is <code>.</code> or <code>..</code>.  This is for
instance desirable if files have to be compare in which case different
names can refer to the same inode.

<p>
<table width="100%">
<tr>
<td align="left">char * <b>canonicalize_file_name</b><i> (const char *<var>name</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<p>The <code>canonicalize_file_name</code> function returns the absolute name of
the file named by <var>name</var> which contains no <code>.</code>, <code>..</code>
components nor any repeated path separators (<code>/</code>) or symlinks.  The
result is passed back as the return value of the function in a block of
memory allocated with <code>malloc</code>.  If the result is not used anymore
the memory should be freed with a call to <code>free</code>.

<p>In any of the path components except the last one is missing the
function returns a NULL pointer.  This is also what is returned if the
length of the path reaches or exceeds <code>PATH_MAX</code> characters.  In
any case <code>errno</code> is set accordingly.

<dl>
<dt><code>ENAMETOOLONG</code>
<dd>The resulting path is too long.  This error only occurs on systems which
have a limit on the file name length.

<br><dt><code>EACCES</code>
<dd>At least one of the path components is not readable.

<br><dt><code>ENOENT</code>
<dd>The input file name is empty.

<br><dt><code>ENOENT</code>
<dd>At least one of the path components does not exist.

<br><dt><code>ELOOP</code>
<dd>More than <code>MAXSYMLINKS</code> many symlinks have been followed. 
</dl>

<p>This function is a GNU extension and is declared in <code>stdlib.h</code>. 
</td></tr>
</table>

<p>The Unix standard includes a similar function which differs from
<code>canonicalize_file_name</code> in that the user has to provide the buffer
where the result is placed in.

<p>
<table width="100%">
<tr>
<td align="left">char * <b>realpath</b><i> (const char *restrict <var>name</var>, char *restrict <var>resolved</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<p>The <code>realpath</code> function behaves just like
<code>canonicalize_file_name</code> but instead of allocating a buffer for the
result it is placed in the buffer pointed to by <var>resolved</var>.

<p>One other difference is that the buffer <var>resolved</var> will contain the
part of the path component which does not exist or is not readable if
the function returns <code>NULL</code> and <code>errno</code> is set to
<code>EACCES</code> or <code>ENOENT</code>.

<p>This function is declared in <code>stdlib.h</code>. 
</td></tr>
</table>

<p>The advantage of using this function is that it is more widely
available.  The drawback is that it reports failures for long path on
systems which have no limits on the file name length.

</body></html>

