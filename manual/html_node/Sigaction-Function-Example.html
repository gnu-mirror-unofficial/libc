<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Sigaction%20Function%20Example">Sigaction Function Example</a>,
Next:<a rel=next accesskey=n href="Flags-for-Sigaction.html#Flags%20for%20Sigaction">Flags for Sigaction</a>,
Previous:<a rel=previous accesskey=p href="Signal-and-Sigaction.html#Signal%20and%20Sigaction">Signal and Sigaction</a>,
Up:<a rel=up accesskey=u href="Signal-Actions.html#Signal%20Actions">Signal Actions</a>
<hr><br>

<h4><code>sigaction</code> Function Example</h4>

<p>In <a href="Basic-Signal-Handling.html#Basic%20Signal%20Handling">Basic Signal Handling</a>, we gave an example of establishing a
simple handler for termination signals using <code>signal</code>.  Here is an
equivalent example using <code>sigaction</code>:

<br><pre>#include &lt;signal.h&gt;

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p-&gt;next)
    unlink (p-&gt;name);
}

int
main (void)
{
  <small>...</small>
  struct sigaction new_action, old_action;

  /* Set up the structure to specify the new action. */
  new_action.sa_handler = termination_handler;
  sigemptyset (&amp;new_action.sa_mask);
  new_action.sa_flags = 0;

  sigaction (SIGINT, NULL, &amp;old_action);
  if (old_action.sa_handler != SIG_IGN)
    sigaction (SIGINT, &amp;new_action, NULL);
  sigaction (SIGHUP, NULL, &amp;old_action);
  if (old_action.sa_handler != SIG_IGN)
    sigaction (SIGHUP, &amp;new_action, NULL);
  sigaction (SIGTERM, NULL, &amp;old_action);
  if (old_action.sa_handler != SIG_IGN)
    sigaction (SIGTERM, &amp;new_action, NULL);
  <small>...</small>
}
</pre>

<p>The program just loads the <code>new_action</code> structure with the desired
parameters and passes it in the <code>sigaction</code> call.  The usage of
<code>sigemptyset</code> is described later; see <a href="Blocking-Signals.html#Blocking%20Signals">Blocking Signals</a>.

<p>As in the example using <code>signal</code>, we avoid handling signals
previously set to be ignored.  Here we can avoid altering the signal
handler even momentarily, by using the feature of <code>sigaction</code> that
lets us examine the current action without specifying a new one.

<p>Here is another example.  It retrieves information about the current
action for <code>SIGINT</code> without changing that action.

<br><pre>struct sigaction query_action;

if (sigaction (SIGINT, NULL, &amp;query_action) &lt; 0)
  /* <code>sigaction</code> returns -1 in case of error. */
else if (query_action.sa_handler == SIG_DFL)
  /* <code>SIGINT</code> is handled in the default, fatal manner. */
else if (query_action.sa_handler == SIG_IGN)
  /* <code>SIGINT</code> is ignored. */
else
  /* A programmer-defined signal handler is in effect. */
</pre>

</body></html>

