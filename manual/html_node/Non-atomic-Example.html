<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Non-atomic%20Example">Non-atomic Example</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Atomic-Types.html#Atomic%20Types">Atomic Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Atomic-Data-Access.html#Atomic%20Data%20Access">Atomic Data Access</a>
<hr><br>
</div>

<h3 class="subsubsection">Problems with Non-Atomic Access</h5>

<p>Here is an example which shows what can happen if a signal handler runs
in the middle of modifying a variable.  (Interrupting the reading of a
variable can also lead to paradoxical results, but here we only show
writing.)

<pre class="smallexample">     #include &lt;signal.h&gt;
     #include &lt;stdio.h&gt;
     
     struct two_words { int a, b; } memory;
     
     void
     handler(int signum)
     {
        printf ("%d,%d\n", memory.a, memory.b);
        alarm (1);
     }
     
     int
     main (void)
     {
        static struct two_words zeros = { 0, 0 }, ones = { 1, 1 };
        signal (SIGALRM, handler);
        memory = zeros;
        alarm (1);
        while (1)
          {
            memory = zeros;
            memory = ones;
          }
     }
     </pre>

   <p>This program fills <code>memory</code> with zeros, ones, zeros, ones,
alternating forever; meanwhile, once per second, the alarm signal handler
prints the current contents.  (Calling <code>printf</code> in the handler is
safe in this program because it is certainly not being called outside
the handler when the signal happens.)

   <p>Clearly, this program can print a pair of zeros or a pair of ones.  But
that's not all it can do!  On most machines, it takes several
instructions to store a new value in <code>memory</code>, and the value is
stored one word at a time.  If the signal is delivered in between these
instructions, the handler might find that <code>memory.a</code> is zero and
<code>memory.b</code> is one (or vice versa).

   <p>On some machines it may be possible to store a new value in
<code>memory</code> with just one instruction that cannot be interrupted.  On
these machines, the handler will always print two zeros or two ones.

   </body></html>

