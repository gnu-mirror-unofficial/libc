<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Opening%20and%20Closing%20Files">Opening and Closing Files</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="I-O-Primitives.html#I%2fO%20Primitives">I/O Primitives</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Low-Level-I-O.html#Low-Level%20I%2fO">Low-Level I/O</a>
<hr><br>
</div>

<h3 class="section">Opening and Closing Files</h3>

<p>This section describes the primitives for opening and closing files
using file descriptors.  The <code>open</code> and <code>creat</code> functions are
declared in the header file <code>fcntl.h</code>, while <code>close</code> is
declared in <code>unistd.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">int <b>open</b><i> </i>(<i>const char *</i><var>filename</var><i>, int </i><var>flags</var><i></i>[<i>, mode_t </i><var>mode</var><i></i>]<i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>open</code> function creates and returns a new file descriptor
for the file named by <var>filename</var>.  Initially, the file position
indicator for the file is at the beginning of the file.  The argument
<var>mode</var> is used only when a file is created, but it doesn't hurt
to supply the argument in any case.

     <p>The <var>flags</var> argument controls how the file is to be opened.  This is
a bit mask; you create the value by the bitwise OR of the appropriate
parameters (using the <code>|</code> operator in C). 
See <a href="File-Status-Flags.html#File%20Status%20Flags">File Status Flags</a>, for the parameters available.

     <p>The normal return value from <code>open</code> is a non-negative integer file
descriptor.  In the case of an error, a value of -1 is returned
instead.  In addition to the usual file name errors (see <a href="File-Name-Errors.html#File%20Name%20Errors">File Name Errors</a>), the following <code>errno</code> error conditions are defined
for this function:

          <dl>
<dt><code>EACCES</code>
          <dd>The file exists but is not readable/writable as requested by the <var>flags</var>
argument, the file does not exist and the directory is unwritable so
it cannot be created.

          <br><dt><code>EEXIST</code>
          <dd>Both <code>O_CREAT</code> and <code>O_EXCL</code> are set, and the named file already
exists.

          <br><dt><code>EINTR</code>
          <dd>The <code>open</code> operation was interrupted by a signal. 
See <a href="Interrupted-Primitives.html#Interrupted%20Primitives">Interrupted Primitives</a>.

          <br><dt><code>EISDIR</code>
          <dd>The <var>flags</var> argument specified write access, and the file is a directory.

          <br><dt><code>EMFILE</code>
          <dd>The process has too many files open. 
The maximum number of file descriptors is controlled by the
<code>RLIMIT_NOFILE</code> resource limit; see <a href="Limits-on-Resources.html#Limits%20on%20Resources">Limits on Resources</a>.

          <br><dt><code>ENFILE</code>
          <dd>The entire system, or perhaps the file system which contains the
directory, cannot support any additional open files at the moment. 
(This problem cannot happen on the GNU system.)

          <br><dt><code>ENOENT</code>
          <dd>The named file does not exist, and <code>O_CREAT</code> is not specified.

          <br><dt><code>ENOSPC</code>
          <dd>The directory or file system that would contain the new file cannot be
extended, because there is no disk space left.

          <br><dt><code>ENXIO</code>
          <dd><code>O_NONBLOCK</code> and <code>O_WRONLY</code> are both set in the <var>flags</var>
argument, the file named by <var>filename</var> is a FIFO (see <a href="Pipes-and-FIFOs.html#Pipes%20and%20FIFOs">Pipes and FIFOs</a>), and no process has the file open for reading.

          <br><dt><code>EROFS</code>
          <dd>The file resides on a read-only file system and any of <code>O_WRONLY</code>,
<code>O_RDWR</code>, and <code>O_TRUNC</code> are set in the <var>flags</var> argument,
or <code>O_CREAT</code> is set and the file does not already exist. 
</dl>

     <p>If on a 32 bit machine the sources are translated with
<code>_FILE_OFFSET_BITS == 64</code> the function <code>open</code> returns a file
descriptor opened in the large file mode which enables the file handling
functions to use files up to 2^63 bytes in size and offset from
-2^63 to 2^63.  This happens transparently for the user
since all of the lowlevel file handling functions are equally replaced.

     <p>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>open</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <code>open</code> should be
protected using cancellation handlers.

     <p>The <code>open</code> function is the underlying primitive for the <code>fopen</code>
and <code>freopen</code> functions, that create streams. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>open64</b><i> </i>(<i>const char *</i><var>filename</var><i>, int </i><var>flags</var><i></i>[<i>, mode_t </i><var>mode</var><i></i>]<i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is similar to <code>open</code>.  It returns a file descriptor
which can be used to access the file named by <var>filename</var>.  The only
difference is that on 32 bit systems the file is opened in the
large file mode.  I.e., file length and file offsets can exceed 31 bits.

     <p>When the sources are translated with <code>_FILE_OFFSET_BITS == 64</code> this
function is actually available under the name <code>open</code>.  I.e., the
new, extended API using 64 bit file sizes and offsets transparently
replaces the old API. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>creat</b><i> </i>(<i>const char *</i><var>filename</var><i>, mode_t </i><var>mode</var><i></i>)<i>
     </i></td>
<td align="right">Obsolete function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is obsolete.  The call:

     <pre class="smallexample">          creat (<var>filename</var>, <var>mode</var>)
          </pre>

     <p>is equivalent to:

     <pre class="smallexample">          open (<var>filename</var>, O_WRONLY | O_CREAT | O_TRUNC, <var>mode</var>)
          </pre>

     <p>If on a 32 bit machine the sources are translated with
<code>_FILE_OFFSET_BITS == 64</code> the function <code>creat</code> returns a file
descriptor opened in the large file mode which enables the file handling
functions to use files up to 2^63 in size and offset from
-2^63 to 2^63.  This happens transparently for the user
since all of the lowlevel file handling functions are equally replaced. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>creat64</b><i> </i>(<i>const char *</i><var>filename</var><i>, mode_t </i><var>mode</var><i></i>)<i>
     </i></td>
<td align="right">Obsolete function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is similar to <code>creat</code>.  It returns a file descriptor
which can be used to access the file named by <var>filename</var>.  The only
the difference is that on 32 bit systems the file is opened in the
large file mode.  I.e., file length and file offsets can exceed 31 bits.

     <p>To use this file descriptor one must not use the normal operations but
instead the counterparts named <code>*64</code>, e.g., <code>read64</code>.

     <p>When the sources are translated with <code>_FILE_OFFSET_BITS == 64</code> this
function is actually available under the name <code>open</code>.  I.e., the
new, extended API using 64 bit file sizes and offsets transparently
replaces the old API. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>close</b><i> </i>(<i>int </i><var>filedes</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The function <code>close</code> closes the file descriptor <var>filedes</var>. 
Closing a file has the following consequences:

          <ul>
<li>The file descriptor is deallocated.

          <li>Any record locks owned by the process on the file are unlocked.

          <li>When all file descriptors associated with a pipe or FIFO have been closed,
any unread data is discarded. 
</ul>

     <p>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>close</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this, calls to <code>close</code> should be
protected using cancellation handlers.

     <p>The normal return value from <code>close</code> is 0; a value of -1
is returned in case of failure.  The following <code>errno</code> error
conditions are defined for this function:

          <dl>
<dt><code>EBADF</code>
          <dd>The <var>filedes</var> argument is not a valid file descriptor.

          <br><dt><code>EINTR</code>
          <dd>The <code>close</code> call was interrupted by a signal. 
See <a href="Interrupted-Primitives.html#Interrupted%20Primitives">Interrupted Primitives</a>. 
Here is an example of how to handle <code>EINTR</code> properly:

          <pre class="smallexample">               TEMP_FAILURE_RETRY (close (desc));
               </pre>

          <br><dt><code>ENOSPC</code>
          <dd><dt><code>EIO</code>
          <dd><dt><code>EDQUOT</code>
          <dd>When the file is accessed by NFS, these errors from <code>write</code> can sometimes
not be detected until <code>close</code>.  See <a href="I-O-Primitives.html#I%2fO%20Primitives">I/O Primitives</a>, for details
on their meaning. 
</dl>

     <p>Please note that there is <em>no</em> separate <code>close64</code> function. 
This is not necessary since this function does not determine nor depend
on the mode of the file.  The kernel which performs the <code>close</code>
operation knows which mode the descriptor is used for and can handle
this situation. 
</td></tr>
</table>

   <p>To close a stream, call <code>fclose</code> (see <a href="Closing-Streams.html#Closing%20Streams">Closing Streams</a>) instead
of trying to close its underlying file descriptor with <code>close</code>. 
This flushes any buffered output and updates the stream object to
indicate that it is closed.

   </body></html>

