<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Obstack%20Streams">Obstack Streams</a>,
Next:<a rel=next accesskey=n href="Custom-Streams.html#Custom%20Streams">Custom Streams</a>,
Previous:<a rel=previous accesskey=p href="String-Streams.html#String%20Streams">String Streams</a>,
Up:<a rel=up accesskey=u href="Other-Kinds-of-Streams.html#Other%20Kinds%20of%20Streams">Other Kinds of Streams</a>
<hr><br>

<h4>Obstack Streams</h4>

<p>You can open an output stream that puts it data in an obstack. 
See <a href="Obstacks.html#Obstacks">Obstacks</a>.

<p>
<table width="100%">
<tr>
<td align="left">FILE * <b>open_obstack_stream</b><i> (struct obstack *<var>obstack</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function opens a stream for writing data into the obstack <var>obstack</var>. 
This starts an object in the obstack and makes it grow as data is
written (see <a href="Growing-Objects.html#Growing%20Objects">Growing Objects</a>).

<p>Calling <code>fflush</code> on this stream updates the current size of the
object to match the amount of data that has been written.  After a call
to <code>fflush</code>, you can examine the object temporarily.

<p>You can move the file position of an obstack stream with <code>fseek</code> or
<code>fseeko</code> (see <a href="File-Positioning.html#File%20Positioning">File Positioning</a>).  Moving the file position past
the end of the data written fills the intervening space with zeros.

<p>To make the object permanent, update the obstack with <code>fflush</code>, and
then use <code>obstack_finish</code> to finalize the object and get its address. 
The following write to the stream starts a new object in the obstack,
and later writes add to that object until you do another <code>fflush</code>
and <code>obstack_finish</code>.

<p>But how do you find out how long the object is?  You can get the length
in bytes by calling <code>obstack_object_size</code> (see <a href="Status-of-an-Obstack.html#Status%20of%20an%20Obstack">Status of an Obstack</a>), or you can null-terminate the object like this:

<br><pre>obstack_1grow (<var>obstack</var>, 0);
</pre>

<p>Whichever one you do, you must do it <em>before</em> calling
<code>obstack_finish</code>.  (You can do both if you wish.) 
</td></tr>
</table>

<p>Here is a sample function that uses <code>open_obstack_stream</code>:

<br><pre>char *
make_message_string (const char *a, int b)
{
  FILE *stream = open_obstack_stream (&amp;message_obstack);
  output_task (stream);
  fprintf (stream, ": ");
  fprintf (stream, a, b);
  fprintf (stream, "\n");
  fclose (stream);
  obstack_1grow (&amp;message_obstack, 0);
  return obstack_finish (&amp;message_obstack);
}
</pre>

</body></html>

