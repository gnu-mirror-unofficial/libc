<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Obstack%20Streams">Obstack Streams</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Custom-Streams.html#Custom%20Streams">Custom Streams</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="String-Streams.html#String%20Streams">String Streams</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Other-Kinds-of-Streams.html#Other%20Kinds%20of%20Streams">Other Kinds of Streams</a>
<hr><br>
</div>

<h3 class="subsection">Obstack Streams</h4>

<p>You can open an output stream that puts it data in an obstack. 
See <a href="Obstacks.html#Obstacks">Obstacks</a>.

<p>
<table width="100%">
<tr>
<td align="left">FILE * <b>open_obstack_stream</b><i> </i>(<i>struct obstack *</i><var>obstack</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function opens a stream for writing data into the obstack <var>obstack</var>. 
This starts an object in the obstack and makes it grow as data is
written (see <a href="Growing-Objects.html#Growing%20Objects">Growing Objects</a>).

     <p>Calling <code>fflush</code> on this stream updates the current size of the
object to match the amount of data that has been written.  After a call
to <code>fflush</code>, you can examine the object temporarily.

     <p>You can move the file position of an obstack stream with <code>fseek</code> or
<code>fseeko</code> (see <a href="File-Positioning.html#File%20Positioning">File Positioning</a>).  Moving the file position past
the end of the data written fills the intervening space with zeros.

     <p>To make the object permanent, update the obstack with <code>fflush</code>, and
then use <code>obstack_finish</code> to finalize the object and get its address. 
The following write to the stream starts a new object in the obstack,
and later writes add to that object until you do another <code>fflush</code>
and <code>obstack_finish</code>.

     <p>But how do you find out how long the object is?  You can get the length
in bytes by calling <code>obstack_object_size</code> (see <a href="Status-of-an-Obstack.html#Status%20of%20an%20Obstack">Status of an Obstack</a>), or you can null-terminate the object like this:

     <pre class="smallexample">          obstack_1grow (<var>obstack</var>, 0);
          </pre>

     <p>Whichever one you do, you must do it <em>before</em> calling
<code>obstack_finish</code>.  (You can do both if you wish.) 
</td></tr>
</table>

   <p>Here is a sample function that uses <code>open_obstack_stream</code>:

<pre class="smallexample">     char *
     make_message_string (const char *a, int b)
     {
       FILE *stream = open_obstack_stream (&amp;message_obstack);
       output_task (stream);
       fprintf (stream, ": ");
       fprintf (stream, a, b);
       fprintf (stream, "\n");
       fclose (stream);
       obstack_1grow (&amp;message_obstack, 0);
       return obstack_finish (&amp;message_obstack);
     }
     </pre>

   </body></html>

