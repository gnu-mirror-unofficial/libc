<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Temporary%20Files">Temporary Files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Making-Special-Files.html#Making%20Special%20Files">Making Special Files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="File-System-Interface.html#File%20System%20Interface">File System Interface</a>
<hr><br>
</div>

<h3 class="section">Temporary Files</h3>

<p>If you need to use a temporary file in your program, you can use the
<code>tmpfile</code> function to open it.  Or you can use the <code>tmpnam</code>
(better: <code>tmpnam_r</code>) function to provide a name for a temporary
file and then you can open it in the usual way with <code>fopen</code>.

   <p>The <code>tempnam</code> function is like <code>tmpnam</code> but lets you choose
what directory temporary files will go in, and something about what
their file names will look like.  Important for multi-threaded programs
is that <code>tempnam</code> is reentrant, while <code>tmpnam</code> is not since it
returns a pointer to a static buffer.

   <p>These facilities are declared in the header file <code>stdio.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">FILE * <b>tmpfile</b><i> </i>(<i>void</i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function creates a temporary binary file for update mode, as if by
calling <code>fopen</code> with mode <code>"wb+"</code>.  The file is deleted
automatically when it is closed or when the program terminates.  (On
some other ISO&nbsp;C systems the file may fail to be deleted if the program
terminates abnormally).

     <p>This function is reentrant.

     <p>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> on a
32-bit system this function is in fact <code>tmpfile64</code>, i.e. the LFS
interface transparently replaces the old interface. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">FILE * <b>tmpfile64</b><i> </i>(<i>void</i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is similar to <code>tmpfile</code>, but the stream it returns a
pointer to was opened using <code>tmpfile64</code>.  Therefore this stream can
be used for files larger then 2^31 bytes on 32-bit machines.

     <p>Please note that the return type is still <code>FILE *</code>.  There is no
special <code>FILE</code> type for the LFS interface.

     <p>If the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> on a 32
bits machine this function is available under the name <code>tmpfile</code>
and so transparently replaces the old interface. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>tmpnam</b><i> </i>(<i>char *</i><var>result</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function constructs and returns a valid file name that does not
refer to any existing file.  If the <var>result</var> argument is a null
pointer, the return value is a pointer to an internal static string,
which might be modified by subsequent calls and therefore makes this
function non-reentrant.  Otherwise, the <var>result</var> argument should be
a pointer to an array of at least <code>L_tmpnam</code> characters, and the
result is written into that array.

     <p>It is possible for <code>tmpnam</code> to fail if you call it too many times
without removing previously-created files.  This is because the limited
length of the temporary file names gives room for only a finite number
of different names.  If <code>tmpnam</code> fails it returns a null pointer.

     <p><strong>Warning:</strong> Between the time the pathname is constructed and the
file is created another process might have created a file with the same
name using <code>tmpnam</code>, leading to a possible security hole.  The
implementation generates names which can hardly be predicted, but when
opening the file you should use the <code>O_EXCL</code> flag.  Using
<code>tmpfile</code> or <code>mkstemp</code> is a safe way to avoid this problem. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>tmpnam_r</b><i> </i>(<i>char *</i><var>result</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function is nearly identical to the <code>tmpnam</code> function, except
that if <var>result</var> is a null pointer it returns a null pointer.

     <p>This guarantees reentrancy because the non-reentrant situation of
<code>tmpnam</code> cannot happen here.

     <p><strong>Warning</strong>: This function has the same security problems as
<code>tmpnam</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>L_tmpnam</b><i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The value of this macro is an integer constant expression that
represents the minimum size of a string large enough to hold a file name
generated by the <code>tmpnam</code> function. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>TMP_MAX</b><i>
     </i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The macro <code>TMP_MAX</code> is a lower bound for how many temporary names
you can create with <code>tmpnam</code>.  You can rely on being able to call
<code>tmpnam</code> at least this many times before it might fail saying you
have made too many temporary file names.

     <p>With the GNU library, you can create a very large number of temporary
file names.  If you actually created the files, you would probably run
out of disk space before you ran out of names.  Some other systems have
a fixed, small limit on the number of temporary files.  The limit is
never less than <code>25</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>tempnam</b><i> </i>(<i>const char *</i><var>dir</var><i>, const char *</i><var>prefix</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function generates a unique temporary file name.  If <var>prefix</var>
is not a null pointer, up to five characters of this string are used as
a prefix for the file name.  The return value is a string newly
allocated with <code>malloc</code>, so you should release its storage with
<code>free</code> when it is no longer needed.

     <p>Because the string is dynamically allocated this function is reentrant.

     <p>The directory prefix for the temporary file name is determined by
testing each of the following in sequence.  The directory must exist and
be writable.

          <ul>
<li>The environment variable <code>TMPDIR</code>, if it is defined.  For security
reasons this only happens if the program is not SUID or SGID enabled.

          <li>The <var>dir</var> argument, if it is not a null pointer.

          <li>The value of the <code>P_tmpdir</code> macro.

          <li>The directory <code>/tmp</code>. 
</ul>

     <p>This function is defined for SVID compatibility.

     <p><strong>Warning:</strong> Between the time the pathname is constructed and the
file is created another process might have created a file with the same
name using <code>tempnam</code>, leading to a possible security hole.  The
implementation generates names which can hardly be predicted, but when
opening the file you should use the <code>O_EXCL</code> flag.  Using
<code>tmpfile</code> or <code>mkstemp</code> is a safe way to avoid this problem. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>P_tmpdir</b><i>
     </i></td>
<td align="right">SVID Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This macro is the name of the default directory for temporary files. 
</td></tr>
</table>

   <p>Older Unix systems did not have the functions just described.  Instead
they used <code>mktemp</code> and <code>mkstemp</code>.  Both of these functions
work by modifying a file name template string you pass.  The last six
characters of this string must be <code>XXXXXX</code>.  These six <code>X</code>s
are replaced with six characters which make the whole string a unique
file name.  Usually the template string is something like
<code>/tmp/</code><var>prefix</var><code>XXXXXX</code>, and each program uses a unique <var>prefix</var>.

   <p><strong>Note:</strong> Because <code>mktemp</code> and <code>mkstemp</code> modify the
template string, you <em>must not</em> pass string constants to them. 
String constants are normally in read-only storage, so your program
would crash when <code>mktemp</code> or <code>mkstemp</code> tried to modify the
string.  These functions are declared in the header file <code>stdlib.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mktemp</b><i> </i>(<i>char *</i><var>template</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>mktemp</code> function generates a unique file name by modifying
<var>template</var> as described above.  If successful, it returns
<var>template</var> as modified.  If <code>mktemp</code> cannot find a unique file
name, it makes <var>template</var> an empty string and returns that.  If
<var>template</var> does not end with <code>XXXXXX</code>, <code>mktemp</code> returns a
null pointer.

     <p><strong>Warning:</strong> Between the time the pathname is constructed and the
file is created another process might have created a file with the same
name using <code>mktemp</code>, leading to a possible security hole.  The
implementation generates names which can hardly be predicted, but when
opening the file you should use the <code>O_EXCL</code> flag.  Using
<code>mkstemp</code> is a safe way to avoid this problem. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mkstemp</b><i> </i>(<i>char *</i><var>template</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>mkstemp</code> function generates a unique file name just as
<code>mktemp</code> does, but it also opens the file for you with <code>open</code>
(see <a href="Opening-and-Closing-Files.html#Opening%20and%20Closing%20Files">Opening and Closing Files</a>).  If successful, it modifies
<var>template</var> in place and returns a file descriptor for that file open
for reading and writing.  If <code>mkstemp</code> cannot create a
uniquely-named file, it returns <code>-1</code>.  If <var>template</var> does not
end with <code>XXXXXX</code>, <code>mkstemp</code> returns <code>-1</code> and does not
modify <var>template</var>.

     <p>The file is opened using mode <code>0600</code>.  If the file is meant to be
used by other users this mode must be changed explicitly. 
</td></tr>
</table>

   <p>Unlike <code>mktemp</code>, <code>mkstemp</code> is actually guaranteed to create a
unique file that cannot possibly clash with any other program trying to
create a temporary file.  This is because it works by calling
<code>open</code> with the <code>O_EXCL</code> flag, which says you want to create a
new file and get an error if the file already exists.

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mkdtemp</b><i> </i>(<i>char *</i><var>template</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>mkdtemp</code> function creates a directory with a unique name.  If
it succeeds, it overwrites <var>template</var> with the name of the
directory, and returns <var>template</var>.  As with <code>mktemp</code> and
<code>mkstemp</code>, <var>template</var> should be a string ending with
<code>XXXXXX</code>.

     <p>If <code>mkdtemp</code> cannot create an uniquely named directory, it returns
<code>NULL</code> and sets <var>errno</var> appropriately.  If <var>template</var> does
not end with <code>XXXXXX</code>, <code>mkdtemp</code> returns <code>NULL</code> and does
not modify <var>template</var>.  <var>errno</var> will be set to <code>EINVAL</code> in
this case.

     <p>The directory is created using mode <code>0700</code>. 
</td></tr>
</table>

   <p>The directory created by <code>mkdtemp</code> cannot clash with temporary
files or directories created by other users.  This is because directory
creation always works like <code>open</code> with <code>O_EXCL</code>. 
See <a href="Creating-Directories.html#Creating%20Directories">Creating Directories</a>.

   <p>The <code>mkdtemp</code> function comes from OpenBSD.

   </body></html>

