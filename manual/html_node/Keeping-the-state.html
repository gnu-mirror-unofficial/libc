<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Keeping%20the%20state">Keeping the state</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Converting-a-Character.html#Converting%20a%20Character">Converting a Character</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Selecting-the-Conversion.html#Selecting%20the%20Conversion">Selecting the Conversion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Restartable-multibyte-conversion.html#Restartable%20multibyte%20conversion">Restartable multibyte conversion</a>
<hr><br>
</div>

<h3 class="subsection">Representing the state of the conversion</h4>

<p>In the introduction of this chapter it was said that certain character
sets use a <dfn>stateful</dfn> encoding.  That is, the encoded values depend
in some way on the previous bytes in the text.

   <p>Since the conversion functions allow converting a text in more than one
step we must have a way to pass this information from one call of the
functions to another.

<p>
<table width="100%">
<tr>
<td align="left"><b>mbstate_t</b><i>
     </i></td>
<td align="right">Data type</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
A variable of type <code>mbstate_t</code> can contain all the information
about the <dfn>shift state</dfn> needed from one call to a conversion
function to another.

     <p><code>mbstate_t</code> is defined in <code>wchar.h</code>.  It was introduced in
Amendment&nbsp;1 to ISO&nbsp;C90. 
</td></tr>
</table>

   <p>To use objects of type <code>mbstate_t</code> the programmer has to define such
objects (normally as local variables on the stack) and pass a pointer to
the object to the conversion functions.  This way the conversion function
can update the object if the current multibyte character set is stateful.

   <p>There is no specific function or initializer to put the state object in
any specific state.  The rules are that the object should always
represent the initial state before the first use, and this is achieved by
clearing the whole variable with code such as follows:

<pre class="smallexample">     {
       mbstate_t state;
       memset (&amp;state, '\0', sizeof (state));
       /* from now on <var>state</var> can be used.  */
       ...
     }
     </pre>

   <p>When using the conversion functions to generate output it is often
necessary to test whether the current state corresponds to the initial
state.  This is necessary, for example, to decide whether to emit
escape sequences to set the state to the initial state at certain
sequence points.  Communication protocols often require this.

<p>
<table width="100%">
<tr>
<td align="left">int <b>mbsinit</b><i> </i>(<i>const mbstate_t *</i><var>ps</var><i></i>)<i>
     </i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>mbsinit</code> function determines whether the state object pointed
to by <var>ps</var> is in the initial state.  If <var>ps</var> is a null pointer or
the object is in the initial state the return value is nonzero.  Otherwise
it is zero.

     <p><code>mbsinit</code> was introduced in Amendment&nbsp;1 to ISO&nbsp;C90 and is
declared in <code>wchar.h</code>. 
</td></tr>
</table>

   <p>Code using <code>mbsinit</code> often looks similar to this:

<pre class="smallexample">     {
       mbstate_t state;
       memset (&amp;state, '\0', sizeof (state));
       /* Use <var>state</var>.  */
       ...
       if (! mbsinit (&amp;state))
         {
           /* Emit code to return to initial state.  */
           const wchar_t empty[] = L"";
           const wchar_t *srcp = empty;
           wcsrtombs (outbuf, &amp;srcp, outbuflen, &amp;state);
         }
       ...
     }
     </pre>

   <p>The code to emit the escape sequence to get back to the initial state is
interesting.  The <code>wcsrtombs</code> function can be used to determine the
necessary output code (see <a href="Converting-Strings.html#Converting%20Strings">Converting Strings</a>).  Please note that on
GNU systems it is not necessary to perform this extra action for the
conversion from multibyte text to wide character text since the wide
character encoding is not stateful.  But there is nothing mentioned in
any standard that prohibits making <code>wchar_t</code> using a stateful
encoding.

   </body></html>

