<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Finding%20Tokens%20in%20a%20String">Finding Tokens in a String</a>,
Next:<a rel=next accesskey=n href="strfry.html#strfry">strfry</a>,
Previous:<a rel=previous accesskey=p href="Search-Functions.html#Search%20Functions">Search Functions</a>,
Up:<a rel=up accesskey=u href="String-and-Array-Utilities.html#String%20and%20Array%20Utilities">String and Array Utilities</a>
<hr><br>

<h3>Finding Tokens in a String</h3>

<p>It's fairly common for programs to have a need to do some simple kinds
of lexical analysis and parsing, such as splitting a command string up
into tokens.  You can do this with the <code>strtok</code> function, declared
in the header file <code>string.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strtok</b><i> (char *restrict <var>newstring</var>, const char *restrict <var>delimiters</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
A string can be split into tokens by making a series of calls to the
function <code>strtok</code>.

<p>The string to be split up is passed as the <var>newstring</var> argument on
the first call only.  The <code>strtok</code> function uses this to set up
some internal state information.  Subsequent calls to get additional
tokens from the same string are indicated by passing a null pointer as
the <var>newstring</var> argument.  Calling <code>strtok</code> with another
non-null <var>newstring</var> argument reinitializes the state information. 
It is guaranteed that no other library function ever calls <code>strtok</code>
behind your back (which would mess up this internal state information).

<p>The <var>delimiters</var> argument is a string that specifies a set of delimiters
that may surround the token being extracted.  All the initial characters
that are members of this set are discarded.  The first character that is
<em>not</em> a member of this set of delimiters marks the beginning of the
next token.  The end of the token is found by looking for the next
character that is a member of the delimiter set.  This character in the
original string <var>newstring</var> is overwritten by a null character, and the
pointer to the beginning of the token in <var>newstring</var> is returned.

<p>On the next call to <code>strtok</code>, the searching begins at the next
character beyond the one that marked the end of the previous token. 
Note that the set of delimiters <var>delimiters</var> do not have to be the
same on every call in a series of calls to <code>strtok</code>.

<p>If the end of the string <var>newstring</var> is reached, or if the remainder of
string consists only of delimiter characters, <code>strtok</code> returns
a null pointer.

<p>Note that "character" is here used in the sense of byte.  In a string
using a multibyte character encoding (abstract) character consisting of
more than one byte are not treated as an entity.  Each byte is treated
separately.  The function is not locale-dependent.

<p>Note that "character" is here used in the sense of byte.  In a string
using a multibyte character encoding (abstract) character consisting of
more than one byte are not treated as an entity.  Each byte is treated
separately.  The function is not locale-dependent. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wcstok</b><i> (wchar_t *<var>newstring</var>, const char *<var>delimiters</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
A string can be split into tokens by making a series of calls to the
function <code>wcstok</code>.

<p>The string to be split up is passed as the <var>newstring</var> argument on
the first call only.  The <code>wcstok</code> function uses this to set up
some internal state information.  Subsequent calls to get additional
tokens from the same wide character string are indicated by passing a
null pointer as the <var>newstring</var> argument.  Calling <code>wcstok</code>
with another non-null <var>newstring</var> argument reinitializes the state
information.  It is guaranteed that no other library function ever calls
<code>wcstok</code> behind your back (which would mess up this internal state
information).

<p>The <var>delimiters</var> argument is a wide character string that specifies
a set of delimiters that may surround the token being extracted.  All
the initial wide characters that are members of this set are discarded. 
The first wide character that is <em>not</em> a member of this set of
delimiters marks the beginning of the next token.  The end of the token
is found by looking for the next wide character that is a member of the
delimiter set.  This wide character in the original wide character
string <var>newstring</var> is overwritten by a null wide character, and the
pointer to the beginning of the token in <var>newstring</var> is returned.

<p>On the next call to <code>wcstok</code>, the searching begins at the next
wide character beyond the one that marked the end of the previous token. 
Note that the set of delimiters <var>delimiters</var> do not have to be the
same on every call in a series of calls to <code>wcstok</code>.

<p>If the end of the wide character string <var>newstring</var> is reached, or
if the remainder of string consists only of delimiter wide characters,
<code>wcstok</code> returns a null pointer.

<p>Note that "character" is here used in the sense of byte.  In a string
using a multibyte character encoding (abstract) character consisting of
more than one byte are not treated as an entity.  Each byte is treated
separately.  The function is not locale-dependent. 
</td></tr>
</table>

<p><strong>Warning:</strong> Since <code>strtok</code> and <code>wcstok</code> alter the string
they is parsing, you should always copy the string to a temporary buffer
before parsing it with <code>strtok</code>/<code>wcstok</code> (see <a href="Copying-and-Concatenation.html#Copying%20and%20Concatenation">Copying and Concatenation</a>).  If you allow <code>strtok</code> or <code>wcstok</code> to modify
a string that came from another part of your program, you are asking for
trouble; that string might be used for other purposes after
<code>strtok</code> or <code>wcstok</code> has modified it, and it would not have
the expected value.

<p>The string that you are operating on might even be a constant.  Then
when <code>strtok</code> or <code>wcstok</code> tries to modify it, your program
will get a fatal signal for writing in read-only memory.  See <a href="Program-Error-Signals.html#Program%20Error%20Signals">Program Error Signals</a>.  Even if the operation of <code>strtok</code> or <code>wcstok</code>
would not require a modification of the string (e.g., if there is
exactly one token) the string can (and in the GNU libc case will) be
modified.

<p>This is a special case of a general principle: if a part of a program
does not have as its purpose the modification of a certain data
structure, then it is error-prone to modify the data structure
temporarily.

<p>The functions <code>strtok</code> and <code>wcstok</code> are not reentrant. 
See <a href="Nonreentrancy.html#Nonreentrancy">Nonreentrancy</a>, for a discussion of where and why reentrancy is
important.

<p>Here is a simple example showing the use of <code>strtok</code>.

<br><pre>#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

<small>...</small>

const char string[] = "words separated by spaces -- and, punctuation!";
const char delimiters[] = " .,;:!-";
char *token, *cp;

<small>...</small>

cp = strdupa (string);                /* Make writable copy.  */
token = strtok (cp, delimiters);      /* token =&gt; "words" */
token = strtok (NULL, delimiters);    /* token =&gt; "separated" */
token = strtok (NULL, delimiters);    /* token =&gt; "by" */
token = strtok (NULL, delimiters);    /* token =&gt; "spaces" */
token = strtok (NULL, delimiters);    /* token =&gt; "and" */
token = strtok (NULL, delimiters);    /* token =&gt; "punctuation" */
token = strtok (NULL, delimiters);    /* token =&gt; NULL */
</pre>

<p>The GNU C library contains two more functions for tokenizing a string
which overcome the limitation of non-reentrancy.  They are only
available for multibyte character strings.

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strtok_r</b><i> (char *<var>newstring</var>, const char *<var>delimiters</var>, char **<var>save_ptr</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Just like <code>strtok</code>, this function splits the string into several
tokens which can be accessed by successive calls to <code>strtok_r</code>. 
The difference is that the information about the next token is stored in
the space pointed to by the third argument, <var>save_ptr</var>, which is a
pointer to a string pointer.  Calling <code>strtok_r</code> with a null
pointer for <var>newstring</var> and leaving <var>save_ptr</var> between the calls
unchanged does the job without hindering reentrancy.

<p>This function is defined in POSIX.1 and can be found on many systems
which support multi-threading. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strsep</b><i> (char **<var>string_ptr</var>, const char *<var>delimiter</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function has a similar functionality as <code>strtok_r</code> with the
<var>newstring</var> argument replaced by the <var>save_ptr</var> argument.  The
initialization of the moving pointer has to be done by the user. 
Successive calls to <code>strsep</code> move the pointer along the tokens
separated by <var>delimiter</var>, returning the address of the next token
and updating <var>string_ptr</var> to point to the beginning of the next
token.

<p>One difference between <code>strsep</code> and <code>strtok_r</code> is that if the
input string contains more than one character from <var>delimiter</var> in a
row <code>strsep</code> returns an empty string for each pair of characters
from <var>delimiter</var>.  This means that a program normally should test
for <code>strsep</code> returning an empty string before processing it.

<p>This function was introduced in 4.3BSD and therefore is widely available. 
</td></tr>
</table>

<p>Here is how the above example looks like when <code>strsep</code> is used.

<br><pre>#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

<small>...</small>

const char string[] = "words separated by spaces -- and, punctuation!";
const char delimiters[] = " .,;:!-";
char *running;
char *token;

<small>...</small>

running = strdupa (string);
token = strsep (&amp;running, delimiters);    /* token =&gt; "words" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "separated" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "by" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "spaces" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "and" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "punctuation" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; NULL */
</pre>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>basename</b><i> (const char *<var>filename</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The GNU version of the <code>basename</code> function returns the last
component of the path in <var>filename</var>.  This function is the preferred
usage, since it does not modify the argument, <var>filename</var>, and
respects trailing slashes.  The prototype for <code>basename</code> can be
found in <code>string.h</code>.  Note, this function is overriden by the XPG
version, if <code>libgen.h</code> is included.

<p>Example of using GNU <code>basename</code>:

<br><pre>#include &lt;string.h&gt;

int
main (int argc, char *argv[])
{
  char *prog = basename (argv[0]);

  if (argc &lt; 2)
    {
      fprintf (stderr, "Usage %s &lt;arg&gt;\n", prog);
      exit (1);
    }

  <small>...</small>
}
</pre>

<p><strong>Portability Note:</strong> This function may produce different results
on different systems.

</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>basename</b><i> (char *<var>path</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This is the standard XPG defined <code>basename</code>. It is similar in
spirit to the GNU version, but may modify the <var>path</var> by removing
trailing '/' characters.  If the <var>path</var> is made up entirely of '/'
characters, then "/" will be returned.  Also, if <var>path</var> is
<code>NULL</code> or an empty string, then "." is returned.  The prototype for
the XPG version can be found in <code>libgen.h</code>.

<p>Example of using XPG <code>basename</code>:

<br><pre>#include &lt;libgen.h&gt;

int
main (int argc, char *argv[])
{
  char *prog;
  char *path = strdupa (argv[0]);

  prog = basename (path);

  if (argc &lt; 2)
    {
      fprintf (stderr, "Usage %s &lt;arg&gt;\n", prog);
      exit (1);
    }

  <small>...</small>

}
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>dirname</b><i> (char *<var>path</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>dirname</code> function is the compliment to the XPG version of
<code>basename</code>.  It returns the parent directory of the file specified
by <var>path</var>.  If <var>path</var> is <code>NULL</code>, an empty string, or
contains no '/' characters, then "." is returned.  The prototype for this
function can be found in <code>libgen.h</code>. 
</td></tr>
</table>

</body></html>

