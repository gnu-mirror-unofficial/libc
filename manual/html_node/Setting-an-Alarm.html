<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Setting%20an%20Alarm">Setting an Alarm</a>,
Next:<a rel=next accesskey=n href="Sleeping.html#Sleeping">Sleeping</a>,
Previous:<a rel=previous accesskey=p href="Calendar-Time.html#Calendar%20Time">Calendar Time</a>,
Up:<a rel=up accesskey=u href="Date-and-Time.html#Date%20and%20Time">Date and Time</a>
<hr><br>

<h3>Setting an Alarm</h3>

<p>The <code>alarm</code> and <code>setitimer</code> functions provide a mechanism for a
process to interrupt itself in the future.  They do this by setting a
timer; when the timer expires, the process receives a signal.

<p>Each process has three independent interval timers available:

<ul>
<li>A real-time timer that counts elapsed time.  This timer sends a
<code>SIGALRM</code> signal to the process when it expires.

<li>A virtual timer that counts processor time used by the process.  This timer
sends a <code>SIGVTALRM</code> signal to the process when it expires.

<li>A profiling timer that counts both processor time used by the process,
and processor time spent in system calls on behalf of the process.  This
timer sends a <code>SIGPROF</code> signal to the process when it expires.

<p>This timer is useful for profiling in interpreters.  The interval timer
mechanism does not have the fine granularity necessary for profiling
native code. 
</ul>

<p>You can only have one timer of each kind set at any given time.  If you
set a timer that has not yet expired, that timer is simply reset to the
new value.

<p>You should establish a handler for the appropriate alarm signal using
<code>signal</code> or <code>sigaction</code> before issuing a call to
<code>setitimer</code> or <code>alarm</code>.  Otherwise, an unusual chain of events
could cause the timer to expire before your program establishes the
handler.  In this case it would be terminated, since termination is the
default action for the alarm signals.  See <a href="Signal-Handling.html#Signal%20Handling">Signal Handling</a>.

<p>The <code>setitimer</code> function is the primary means for setting an alarm. 
This facility is declared in the header file <code>sys/time.h</code>.  The
<code>alarm</code> function, declared in <code>unistd.h</code>, provides a somewhat
simpler interface for setting the real-time timer.

<p>
<table width="100%">
<tr>
<td align="left"><b>struct itimerval</b><i>
</i></td>
<td align="right">Data Type</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This structure is used to specify when a timer should expire.  It contains
the following members:
<dl>
<dt><code>struct timeval it_interval</code>
<dd>This is the period between successive timer interrupts.  If zero, the
alarm will only be sent once.

<br><dt><code>struct timeval it_value</code>
<dd>This is the period between now and the first timer interrupt.  If zero,
the alarm is disabled. 
</dl>

<p>The <code>struct timeval</code> data type is described in <a href="Elapsed-Time.html#Elapsed%20Time">Elapsed Time</a>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>setitimer</b><i> (int <var>which</var>, struct itimerval *<var>new</var>, struct itimerval *<var>old</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>setitimer</code> function sets the timer specified by <var>which</var>
according to <var>new</var>.  The <var>which</var> argument can have a value of
<code>ITIMER_REAL</code>, <code>ITIMER_VIRTUAL</code>, or <code>ITIMER_PROF</code>.

<p>If <var>old</var> is not a null pointer, <code>setitimer</code> returns information
about any previous unexpired timer of the same kind in the structure it
points to.

<p>The return value is <code>0</code> on success and <code>-1</code> on failure.  The
following <code>errno</code> error conditions are defined for this function:

<dl>
<dt><code>EINVAL</code>
<dd>The timer period is too large. 
</dl>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>getitimer</b><i> (int <var>which</var>, struct itimerval *<var>old</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>getitimer</code> function stores information about the timer specified
by <var>which</var> in the structure pointed at by <var>old</var>.

<p>The return value and error conditions are the same as for <code>setitimer</code>. 
</td></tr>
</table>

<dl>
<dt><code>ITIMER_REAL</code>
<dd>This constant can be used as the <var>which</var> argument to the
<code>setitimer</code> and <code>getitimer</code> functions to specify the real-time
timer.

<br><dt><code>ITIMER_VIRTUAL</code>
<dd>This constant can be used as the <var>which</var> argument to the
<code>setitimer</code> and <code>getitimer</code> functions to specify the virtual
timer.

<br><dt><code>ITIMER_PROF</code>
<dd>This constant can be used as the <var>which</var> argument to the
<code>setitimer</code> and <code>getitimer</code> functions to specify the profiling
timer. 
</dl>

<p>
<table width="100%">
<tr>
<td align="left">unsigned int <b>alarm</b><i> (unsigned int <var>seconds</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>alarm</code> function sets the real-time timer to expire in
<var>seconds</var> seconds.  If you want to cancel any existing alarm, you
can do this by calling <code>alarm</code> with a <var>seconds</var> argument of
zero.

<p>The return value indicates how many seconds remain before the previous
alarm would have been sent.  If there is no previous alarm, <code>alarm</code>
returns zero. 
</td></tr>
</table>

<p>The <code>alarm</code> function could be defined in terms of <code>setitimer</code>
like this:

<br><pre>unsigned int
alarm (unsigned int seconds)
{
  struct itimerval old, new;
  new.it_interval.tv_usec = 0;
  new.it_interval.tv_sec = 0;
  new.it_value.tv_usec = 0;
  new.it_value.tv_sec = (long int) seconds;
  if (setitimer (ITIMER_REAL, &amp;new, &amp;old) &lt; 0)
    return 0;
  else
    return old.it_value.tv_sec;
}
</pre>

<p>There is an example showing the use of the <code>alarm</code> function in
<a href="Handler-Returns.html#Handler%20Returns">Handler Returns</a>.

<p>If you simply want your process to wait for a given number of seconds,
you should use the <code>sleep</code> function.  See <a href="Sleeping.html#Sleeping">Sleeping</a>.

<p>You shouldn't count on the signal arriving precisely when the timer
expires.  In a multiprocessing environment there is typically some
amount of delay involved.

<p><strong>Portability Note:</strong> The <code>setitimer</code> and <code>getitimer</code>
functions are derived from BSD Unix, while the <code>alarm</code> function is
specified by the POSIX.1 standard.  <code>setitimer</code> is more powerful than
<code>alarm</code>, but <code>alarm</code> is more widely used.

</body></html>

