<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Search%20Functions">Search Functions</a>,
Next:<a rel=next accesskey=n href="Finding-Tokens-in-a-String.html#Finding%20Tokens%20in%20a%20String">Finding Tokens in a String</a>,
Previous:<a rel=previous accesskey=p href="Collation-Functions.html#Collation%20Functions">Collation Functions</a>,
Up:<a rel=up accesskey=u href="String-and-Array-Utilities.html#String%20and%20Array%20Utilities">String and Array Utilities</a>
<hr><br>

<h3>Search Functions</h3>

<p>This section describes library functions which perform various kinds
of searching operations on strings and arrays.  These functions are
declared in the header file <code>string.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">void * <b>memchr</b><i> (const void *<var>block</var>, int <var>c</var>, size_t <var>size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function finds the first occurrence of the byte <var>c</var> (converted
to an <code>unsigned char</code>) in the initial <var>size</var> bytes of the
object beginning at <var>block</var>.  The return value is a pointer to the
located byte, or a null pointer if no match was found. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wmemchr</b><i> (const wchar_t *<var>block</var>, wchar_t <var>wc</var>, size_t <var>size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function finds the first occurrence of the wide character <var>wc</var>
in the initial <var>size</var> wide characters of the object beginning at
<var>block</var>.  The return value is a pointer to the located wide
character, or a null pointer if no match was found. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void * <b>rawmemchr</b><i> (const void *<var>block</var>, int <var>c</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Often the <code>memchr</code> function is used with the knowledge that the
byte <var>c</var> is available in the memory block specified by the
parameters.  But this means that the <var>size</var> parameter is not really
needed and that the tests performed with it at runtime (to check whether
the end of the block is reached) are not needed.

<p>The <code>rawmemchr</code> function exists for just this situation which is
surprisingly frequent.  The interface is similar to <code>memchr</code> except
that the <var>size</var> parameter is missing.  The function will look beyond
the end of the block pointed to by <var>block</var> in case the programmer
made an error in assuming that the byte <var>c</var> is present in the block. 
In this case the result is unspecified.  Otherwise the return value is a
pointer to the located byte.

<p>This function is of special interest when looking for the end of a
string.  Since all strings are terminated by a null byte a call like

<br><pre>   rawmemchr (str, '\0')
</pre>

<p>will never go beyond the end of the string.

<p>This function is a GNU extension. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void * <b>memrchr</b><i> (const void *<var>block</var>, int <var>c</var>, size_t <var>size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The function <code>memrchr</code> is like <code>memchr</code>, except that it searches
backwards from the end of the block defined by <var>block</var> and <var>size</var>
(instead of forwards from the front). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strchr</b><i> (const char *<var>string</var>, int <var>c</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strchr</code> function finds the first occurrence of the character
<var>c</var> (converted to a <code>char</code>) in the null-terminated string
beginning at <var>string</var>.  The return value is a pointer to the located
character, or a null pointer if no match was found.

<p>For example,
<br><pre>strchr ("hello, world", 'l')
    =&gt; "llo, world"
strchr ("hello, world", '?')
    =&gt; NULL
</pre>

<p>The terminating null character is considered to be part of the string,
so you can use this function get a pointer to the end of a string by
specifying a null character as the value of the <var>c</var> argument.  It
would be better (but less portable) to use <code>strchrnul</code> in this
case, though. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wcschr</b><i> (const wchar_t *<var>wstring</var>, int <var>wc</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcschr</code> function finds the first occurrence of the wide
character <var>wc</var> in the null-terminated wide character string
beginning at <var>wstring</var>.  The return value is a pointer to the
located wide character, or a null pointer if no match was found.

<p>The terminating null character is considered to be part of the wide
character string, so you can use this function get a pointer to the end
of a wide character string by specifying a null wude character as the
value of the <var>wc</var> argument.  It would be better (but less portable)
to use <code>wcschrnul</code> in this case, though. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strchrnul</b><i> (const char *<var>string</var>, int <var>c</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>strchrnul</code> is the same as <code>strchr</code> except that if it does
not find the character, it returns a pointer to string's terminating
null character rather than a null pointer.

<p>This function is a GNU extension. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wcschrnul</b><i> (const wchar_t *<var>wstring</var>, wchar_t <var>wc</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>wcschrnul</code> is the same as <code>wcschr</code> except that if it does not
find the wide character, it returns a pointer to wide character string's
terminating null wide character rather than a null pointer.

<p>This function is a GNU extension. 
</td></tr>
</table>

<p>One useful, but unusual, use of the <code>strchr</code>
function is when one wants to have a pointer pointing to the NUL byte
terminating a string.  This is often written in this way:

<br><pre>  s += strlen (s);
</pre>

<p>This is almost optimal but the addition operation duplicated a bit of
the work already done in the <code>strlen</code> function.  A better solution
is this:

<br><pre>  s = strchr (s, '\0');
</pre>

<p>There is no restriction on the second parameter of <code>strchr</code> so it
could very well also be the NUL character.  Those readers thinking very
hard about this might now point out that the <code>strchr</code> function is
more expensive than the <code>strlen</code> function since we have two abort
criteria.  This is right.  But in the GNU C library the implementation of
<code>strchr</code> is optimized in a special way so that <code>strchr</code>
actually is faster.

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strrchr</b><i> (const char *<var>string</var>, int <var>c</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The function <code>strrchr</code> is like <code>strchr</code>, except that it searches
backwards from the end of the string <var>string</var> (instead of forwards
from the front).

<p>For example,
<br><pre>strrchr ("hello, world", 'l')
    =&gt; "ld"
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wcsrchr</b><i> (const wchar_t *<var>wstring</var>, wchar_t <var>c</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The function <code>wcsrchr</code> is like <code>wcschr</code>, except that it searches
backwards from the end of the string <var>wstring</var> (instead of forwards
from the front). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strstr</b><i> (const char *<var>haystack</var>, const char *<var>needle</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This is like <code>strchr</code>, except that it searches <var>haystack</var> for a
substring <var>needle</var> rather than just a single character.  It
returns a pointer into the string <var>haystack</var> that is the first
character of the substring, or a null pointer if no match was found.  If
<var>needle</var> is an empty string, the function returns <var>haystack</var>.

<p>For example,
<br><pre>strstr ("hello, world", "l")
    =&gt; "llo, world"
strstr ("hello, world", "wo")
    =&gt; "world"
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wcsstr</b><i> (const wchar_t *<var>haystack</var>, const wchar_t *<var>needle</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This is like <code>wcschr</code>, except that it searches <var>haystack</var> for a
substring <var>needle</var> rather than just a single wide character.  It
returns a pointer into the string <var>haystack</var> that is the first wide
character of the substring, or a null pointer if no match was found.  If
<var>needle</var> is an empty string, the function returns <var>haystack</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wcswcs</b><i> (const wchar_t *<var>haystack</var>, const wchar_t *<var>needle</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>wcsstr</code> is an depricated alias for <code>wcsstr</code>.  This is the
name originally used in the X/Open Portability Guide before the
Amendment&nbsp;1 to ISO&nbsp;C90 was published. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strcasestr</b><i> (const char *<var>haystack</var>, const char *<var>needle</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This is like <code>strstr</code>, except that it ignores case in searching for
the substring.   Like <code>strcasecmp</code>, it is locale dependent how
uppercase and lowercase characters are related.

<p>For example,
<br><pre>strstr ("hello, world", "L")
    =&gt; "llo, world"
strstr ("hello, World", "wo")
    =&gt; "World"
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void * <b>memmem</b><i> (const void *<var>haystack</var>, size_t <var>haystack-len</var>,<br>const void *<var>needle</var>, size_t <var>needle-len</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This is like <code>strstr</code>, but <var>needle</var> and <var>haystack</var> are byte
arrays rather than null-terminated strings.  <var>needle-len</var> is the
length of <var>needle</var> and <var>haystack-len</var> is the length of
<var>haystack</var>.

<p>This function is a GNU extension. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>strspn</b><i> (const char *<var>string</var>, const char *<var>skipset</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strspn</code> ("string span") function returns the length of the
initial substring of <var>string</var> that consists entirely of characters that
are members of the set specified by the string <var>skipset</var>.  The order
of the characters in <var>skipset</var> is not important.

<p>For example,
<br><pre>strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")
    =&gt; 5
</pre>

<p>Note that "character" is here used in the sense of byte.  In a string
using a multibyte character encoding (abstract) character consisting of
more than one byte are not treated as an entity.  Each byte is treated
separately.  The function is not locale-dependent. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>wcsspn</b><i> (const wchar_t *<var>wstring</var>, const wchar_t *<var>skipset</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcsspn</code> ("wide character string span") function returns the
length of the initial substring of <var>wstring</var> that consists entirely
of wide characters that are members of the set specified by the string
<var>skipset</var>.  The order of the wide characters in <var>skipset</var> is not
important. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>strcspn</b><i> (const char *<var>string</var>, const char *<var>stopset</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strcspn</code> ("string complement span") function returns the length
of the initial substring of <var>string</var> that consists entirely of characters
that are <em>not</em> members of the set specified by the string <var>stopset</var>. 
(In other words, it returns the offset of the first character in <var>string</var>
that is a member of the set <var>stopset</var>.)

<p>For example,
<br><pre>strcspn ("hello, world", " \t\n,.;!?")
    =&gt; 5
</pre>

<p>Note that "character" is here used in the sense of byte.  In a string
using a multibyte character encoding (abstract) character consisting of
more than one byte are not treated as an entity.  Each byte is treated
separately.  The function is not locale-dependent. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>wcscspn</b><i> (const wchar_t *<var>wstring</var>, const wchar_t *<var>stopset</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcscspn</code> ("wide character string complement span") function
returns the length of the initial substring of <var>wstring</var> that
consists entirely of wide characters that are <em>not</em> members of the
set specified by the string <var>stopset</var>.  (In other words, it returns
the offset of the first character in <var>string</var> that is a member of
the set <var>stopset</var>.) 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>strpbrk</b><i> (const char *<var>string</var>, const char *<var>stopset</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>strpbrk</code> ("string pointer break") function is related to
<code>strcspn</code>, except that it returns a pointer to the first character
in <var>string</var> that is a member of the set <var>stopset</var> instead of the
length of the initial substring.  It returns a null pointer if no such
character from <var>stopset</var> is found.

<p>For example,

<br><pre>strpbrk ("hello, world", " \t\n,.;!?")
    =&gt; ", world"
</pre>

<p>Note that "character" is here used in the sense of byte.  In a string
using a multibyte character encoding (abstract) character consisting of
more than one byte are not treated as an entity.  Each byte is treated
separately.  The function is not locale-dependent. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">wchar_t * <b>wcspbrk</b><i> (const wchar_t *<var>wstring</var>, const wchar_t *<var>stopset</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The <code>wcspbrk</code> ("wide character string pointer break") function is
related to <code>wcscspn</code>, except that it returns a pointer to the first
wide character in <var>wstring</var> that is a member of the set
<var>stopset</var> instead of the length of the initial substring.  It
returns a null pointer if no such character from <var>stopset</var> is found. 
</td></tr>
</table>

<h4>Compatibility String Search Functions</h4>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>index</b><i> (const char *<var>string</var>, int <var>c</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>index</code> is another name for <code>strchr</code>; they are exactly the same. 
New code should always use <code>strchr</code> since this name is defined in
ISO&nbsp;C while <code>index</code> is a BSD invention which never was available
on System&nbsp;V derived systems. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>rindex</b><i> (const char *<var>string</var>, int <var>c</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>rindex</code> is another name for <code>strrchr</code>; they are exactly the same. 
New code should always use <code>strrchr</code> since this name is defined in
ISO&nbsp;C while <code>rindex</code> is a BSD invention which never was available
on System&nbsp;V derived systems. 
</td></tr>
</table>

</body></html>

