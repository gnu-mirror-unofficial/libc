<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Initial%20Signal%20Actions">Initial Signal Actions</a>,
Previous:<a rel=previous accesskey=p href="Flags-for-Sigaction.html#Flags%20for%20Sigaction">Flags for Sigaction</a>,
Up:<a rel=up accesskey=u href="Signal-Actions.html#Signal%20Actions">Signal Actions</a>
<hr><br>

<h4>Initial Signal Actions</h4>

<p>When a new process is created (see <a href="Creating-a-Process.html#Creating%20a%20Process">Creating a Process</a>), it inherits
handling of signals from its parent process.  However, when you load a
new process image using the <code>exec</code> function (see <a href="Executing-a-File.html#Executing%20a%20File">Executing a File</a>), any signals that you've defined your own handlers for revert to
their <code>SIG_DFL</code> handling.  (If you think about it a little, this
makes sense; the handler functions from the old program are specific to
that program, and aren't even present in the address space of the new
program image.)  Of course, the new program can establish its own
handlers.

<p>When a program is run by a shell, the shell normally sets the initial
actions for the child process to <code>SIG_DFL</code> or <code>SIG_IGN</code>, as
appropriate.  It's a good idea to check to make sure that the shell has
not set up an initial action of <code>SIG_IGN</code> before you establish your
own signal handlers.

<p>Here is an example of how to establish a handler for <code>SIGHUP</code>, but
not if <code>SIGHUP</code> is currently ignored:

<br><pre><small>...</small>
struct sigaction temp;

sigaction (SIGHUP, NULL, &amp;temp);

if (temp.sa_handler != SIG_IGN)
  {
    temp.sa_handler = handle_sighup;
    sigemptyset (&amp;temp.sa_mask);
    sigaction (SIGHUP, &amp;temp, NULL);
  }
</pre>

</body></html>

