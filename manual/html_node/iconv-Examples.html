<html lang="en">
<head>
<title>The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The GNU C Library">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="iconv%20Examples">iconv Examples</a>,
Next:<a rel=next accesskey=n href="Other-iconv-Implementations.html#Other%20iconv%20Implementations">Other iconv Implementations</a>,
Previous:<a rel=previous accesskey=p href="Generic-Conversion-Interface.html#Generic%20Conversion%20Interface">Generic Conversion Interface</a>,
Up:<a rel=up accesskey=u href="Generic-Charset-Conversion.html#Generic%20Charset%20Conversion">Generic Charset Conversion</a>
<hr><br>

<h4>A complete <code>iconv</code> example</h4>

<p>The example below features a solution for a common problem.  Given that
one knows the internal encoding used by the system for <code>wchar_t</code>
strings, one often is in the position to read text from a file and store
it in wide character buffers.  One can do this using <code>mbsrtowcs</code>,
but then we run into the problems discussed above.

<br><pre>int
file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
{
  char inbuf[BUFSIZ];
  size_t insize = 0;
  char *wrptr = (char *) outbuf;
  int result = 0;
  iconv_t cd;

  cd = iconv_open ("WCHAR_T", charset);
  if (cd == (iconv_t) -1)
    {
      /* Something went wrong.  */
      if (errno == EINVAL)
        error (0, 0, "conversion from '%s' to wchar_t not available",
               charset);
      else
        perror ("iconv_open");

      /* Terminate the output string.  */
      *outbuf = L'\0';

      return -1;
    }

  while (avail &gt; 0)
    {
      size_t nread;
      size_t nconv;
      char *inptr = inbuf;

      /* Read more input.  */
      nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
      if (nread == 0)
        {
          /* When we come here the file is completely read.
             This still could mean there are some unused
             characters in the <code>inbuf</code>.  Put them back.  */
          if (lseek (fd, -insize, SEEK_CUR) == -1)
            result = -1;

          /* Now write out the byte sequence to get into the
             initial state if this is necessary.  */
          iconv (cd, NULL, NULL, &amp;wrptr, &amp;avail);

          break;
        }
      insize += nread;

      /* Do the conversion.  */
      nconv = iconv (cd, &amp;inptr, &amp;insize, &amp;wrptr, &amp;avail);
      if (nconv == (size_t) -1)
        {
          /* Not everything went right.  It might only be
             an unfinished byte sequence at the end of the
             buffer.  Or it is a real problem.  */
          if (errno == EINVAL)
            /* This is harmless.  Simply move the unused
               bytes to the beginning of the buffer so that
               they can be used in the next round.  */
            memmove (inbuf, inptr, insize);
          else
            {
              /* It is a real problem.  Maybe we ran out of
                 space in the output buffer or we have invalid
                 input.  In any case back the file pointer to
                 the position of the last processed byte.  */
              lseek (fd, -insize, SEEK_CUR);
              result = -1;
              break;
            }
        }
    }

  /* Terminate the output string.  */
  if (avail &gt;= sizeof (wchar_t))
    *((wchar_t *) wrptr) = L'\0';

  if (iconv_close (cd) != 0)
    perror ("iconv_close");

  return (wchar_t *) wrptr - outbuf;
}
</pre>

<p>This example shows the most important aspects of using the <code>iconv</code>
functions.  It shows how successive calls to <code>iconv</code> can be used to
convert large amounts of text.  The user does not have to care about
stateful encodings as the functions take care of everything.

<p>An interesting point is the case where <code>iconv</code> returns an error and
<code>errno</code> is set to <code>EINVAL</code>.  This is not really an error in the
transformation.  It can happen whenever the input character set contains
byte sequences of more than one byte for some character and texts are not
processed in one piece.  In this case there is a chance that a multibyte
sequence is cut.  The caller can then simply read the remainder of the
takes and feed the offending bytes together with new character from the
input to <code>iconv</code> and continue the work.  The internal state kept in
the descriptor is <em>not</em> unspecified after such an event as is the
case with the conversion functions from the ISO&nbsp;C standard.

<p>The example also shows the problem of using wide character strings with
<code>iconv</code>.  As explained in the description of the <code>iconv</code>
function above, the function always takes a pointer to a <code>char</code>
array and the available space is measured in bytes.  In the example, the
output buffer is a wide character buffer; therefore, we use a local
variable <var>wrptr</var> of type <code>char *</code>, which is used in the
<code>iconv</code> calls.

<p>This looks rather innocent but can lead to problems on platforms that
have tight restriction on alignment.  Therefore the caller of <code>iconv</code>
has to make sure that the pointers passed are suitable for access of
characters from the appropriate character set.  Since, in the
above case, the input parameter to the function is a <code>wchar_t</code>
pointer, this is the case (unless the user violates alignment when
computing the parameter).  But in other situations, especially when
writing generic functions where one does not know what type of character
set one uses and, therefore, treats text as a sequence of bytes, it might
become tricky.

</body></html>

